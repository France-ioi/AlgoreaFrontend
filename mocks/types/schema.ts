/* eslint-disable */
/**
 * This file was auto-generated by openapi-typescript.
 * Do not make direct changes to the file.
 */

export interface paths {
  "/answers": {
    /**
     * Generate and return an answer token from user's answer and task token. It is used to bind an answer with task parameters so that the TaskGrader can check if they have not been altered.
     * * task_token.idUser should be the current user.
     * * The user should have submission rights on `task_token.idItemLocal`.
     * * The attempt should allow submission (`attempts.allows_submissions_until` should be a time in the future).
     * If any of the preconditions fails, the 'forbidden' error is returned.
     */
    post: operations["itemGetAnswerToken"];
  };
  "/answers/{answer_id}": {
    /**
     * Returns the answer identified by the given `{answer_id}`.
     * - If the user is a participant
     *   - (s)he should have at least 'content' access rights to the `answers.item_id` and
     *   - be a member of the `answers.participant_id` team or
     *     `answers.participant_id` should be equal to the user's self group.
     *
     * - If the user is an observer
     *   - (s)he should have `can_watch` >= 'answer' permission on the `answers.item_id` and
     *   - be a manager with `can_watch_members` of an ancestor of `answers.participant_id` group.
     *
     * If any of the preconditions fails, the 'forbidden' error is returned.
     */
    get: operations["answerGet"];
  };
  "/attempts/{attempt_id}/end": {
    /**
     * Allows to end an attempt as a user or as a team (if `as_team_id` is given).
     *
     * Restrictions:
     *   * `as_team_id` (if given) should be the current user's team;
     *   * the `{attempt_id}` should not be zero (since implicit attempts cannot be ended);
     *   * an attempt with `participant_id` = `as_team_id` (or the current user) and `id` = `attempt_id`
     *     should exist and not be ended or expired;
     *
     * Otherwise, the "Forbidden" response is returned.
     */
    post: operations["itemAttemptEnd"];
  };
  "/auth/logout": {
    /** Removes the current user’s session (all access and refresh tokens) */
    post: operations["authLogout"];
  };
  "/auth/temp-user": {
    /**
     * Creates a temporary user and generates an access token valid for 2 hours.
     *
     * If attributes of the old and the new 'access_token' cookies are different (or the token is returned in the JSON), the old cookie gets deleted (otherwise, just overwritten).
     * * The "Authorization" header must not be given.
     * * When `{use_cookie}`=1, at least one of `{cookie_secure}` and `{cookie_same_site}` must be true.
     */
    post: operations["tempUserCreate"];
  };
  "/auth/token": {
    /**
     * If the `{code}` is given and the "Authorization" header is not given, the service converts the given OAuth2 authorization code into tokens, creates or updates the authenticated user in the DB with the data returned by the login module, and saves new access & refresh tokens into the DB as well. If OAuth2 authentication has used the PKCE extension, the `{code_verifier}` should be provided so it can be sent together with the `{code}` to the authentication server.
     *
     * If the `{code}` is not given while the "Authorization" header or/and the "access_token" is given (when both are given, the "Authorization" header is used and the cookie gets deleted), the service refreshes the access token (locally for temporary users or via the login module for normal users) and saves it into the DB keeping only the input token and the new token. Since the login module responds with both access and refresh tokens, the service updates the user's refresh token in this case as well. If there is no refresh token for the user in the DB, the 'not found' error is returned.
     *
     * If attributes of the old and the new 'access_token' cookies are different (or the token is returned in the JSON), the old cookie gets deleted (otherwise, just overwritten).
     *
     * * The "Authorization" header is not allowed when the `{code}` is given.
     * * When `{use_cookie}`=1, at least one of `{cookie_secure}` and `{cookie_same_site}` must be true.
     */
    post: operations["accessTokenCreate"];
  };
  "/contests/{item_id}/groups/{group_id}/additional-times": {
    /**
     * For the input group and item, sets the `groups_contest_items.additional_time` to the `time` value. If there is no `groups_contest_items` for the given `group_id`, `item_id` and the `seconds` != 0, creates it (with default values in other columns). If no `groups_contest_items` and `seconds` == 0, succeed without doing any change.
     *
     * `groups_groups.expires_at` & `attempts.allows_submissions_until` (for the latest attempt) of affected `items.participants_group_id` members is set to `results.started_at` + `items.duration` + total additional time.
     *
     * Restrictions:
     *   * `item_id` should be a timed contest;
     *   * the authenticated user should have `can_view` >= 'content' on the input item;
     *   * the authenticated user should have `can_grant_view` >= 'enter' on the input item;
     *   * the authenticated user should have `can_watch` >= 'result' on the input item;
     *   * the authenticated user should be a manager of the `group_id`
     *     with `can_grant_group_access` and `can_watch_members` permissions;
     *   * if the contest is team-only (`items.entry_participant_type` = 'Team'), then the group should not be a user.
     *
     * Otherwise, the "Forbidden" response is returned.
     */
    put: operations["contestSetAdditionalTime"];
  };
  "/contests/{item_id}/groups/{group_id}/members/additional-times": {
    /**
     * For all descendant
     *
     *   * teams if `items.entry_participant_type` = 'Team'
     *   * end-users groups otherwise
     *
     * linked to the item via `attempts.root_item_id` and able to view (at least 'can_view:info') or enter (`can_enter_from` < `can_enter_until`) the item, the service returns their `group_id`, `name`, `type` and `additional_time` & `total_additional_time`.
     *
     * * `additional_time` defaults to 0 if no such `groups_contest_items`
     * * `total_additional_time` is the sum of additional times of this group on the item through all its
     *   `groups_ancestors` (even from different branches, but each ancestors counted only once), defaulting to 0
     *
     * Restrictions:
     *   * `item_id` should be a timed contest;
     *   * the authenticated user should have `can_view` >= 'content', `can_grant_view` >= 'enter',
     *     and `can_watch` >= 'result' on the input item;
     *   * the authenticated user should be a manager of the `group_id`
     *     with `can_grant_group_access` and `can_watch_members` permissions.
     */
    get: operations["contestListMembersAdditionalTime"];
  };
  "/contests/{item_id}/groups/by-name": {
    /**
     * Return one group matching the name and satisfying:
     *
     *   * the group can view (at least 'can_view:info') or enter (`can_enter_from` < `can_enter_until`) the item;
     *   * the authenticated user is a manager of the group with `can_grant_group_access` and `can_watch_members` permissions;
     *   * the `groups.name` (matching `login` if a "User" group) is matching the input `name` parameter (case-insensitive)
     *
     * If there are several groups or users matching, returns the first one (by `id`).
     *
     * If the contest is a team-only contest (`items.entry_participant_type` = 'Team') and the name matches an end-user, returns his team instead of user’s group.
     *
     * Restrictions:
     *   * `item_id` should be a timed contest;
     *   * the authenticated user should have `can_view` >= 'content, `can_grant_view` >= 'enter', and `can_watch` >= 'result'
     *     on the input item.
     *
     * Otherwise, the "Forbidden" response is returned.
     *
     * __NOTE__: This service is only here for transition between the former interface and the new one.
     *       This way of searching only by `name`/`login` and getting one result is not really convenient,
     *       but matching the former UI. This service will have to be removed as soon as
     *       the new interface is used.
     */
    get: operations["contestGetGroupByName"];
  };
  "/contests/administered": {
    /**
     * Get the contests that the user has administration rights on.
     *
     * For all explicit-entry items that are timed contests and for that the user is a contest admin (has `can_view` >= 'content', `can_grant_view` >= 'enter', and `can_watch` >= 'result'), returns item info (`id`, `title`, `team_only_contest`, parents' `title`-s). Only parents visible to the user are listed.
     *
     * Each title is returned in the user's default language if exists, otherwise the item's default language is used.
     */
    get: operations["contestAdminList"];
  };
  "/current-user": {
    /** Returns the data from the `users` table. */
    get: operations["userData"];
    /** Allows changing the user's default language */
    put: operations["userDataUpdate"];
    /**
     * Deletes all information stored in the platform related to the current user and calls the “UnlinkClient” service of the login module.
     * The data to be deleted:
     * 1. [`users_threads`, `filters`, `sessions`, `refresh_tokens`]
     *    having `user_id` = `users.group_id`;
     * 2. `answers` having `author_id` = `users.group_id`;
     * 3. [`permissions_granted`, `permissions_generated`, `attempts`]
     *    having `group_id` = `users.group_id`;
     *
     * 4. `groups_groups` having `parent_group_id` or `child_group_id` equal to `users.group_id`; 5. `group_pending_requests`/`group_membership_changes` having `group_id` or `member_id` equal
     *    to `users.group_id`;
     * 6. `groups_ancestors` having `ancestor_group_id` or `child_group_id` equal
     *    to `users.group_id`;
     * 7. [`groups_propagate`, `groups`] having `id` equal to `users.group_id`; 8. `users` having `group_id` = `users.group_id`.
     *
     * The deletion is rejected if the user is a member of at least one group with `now() < require_lock_membership_approval_until` and `groups_groups.lock_membership_approved` set.
     */
    delete: operations["currentUserDeletion"];
  };
  "/current-user/available-groups": {
    /**
     * Searches for groups that can be joined freely, based on a substring of their name. Returns groups with `is_public` = 1 and `type` != 'User', whose `name` has `search` as a substring, and for that the current user is not already a member and don’t have pending requests/invitations.
     *
     * Note: The current implementation may be very slow because it uses `LIKE` with a percentage wildcard at the beginning. This causes MySQL to explore every row having `is_public`=1. Moreover, actually it has to examine every row of the `groups` table since there is no index for the `is_public` column. But since there are not too many groups and the result rows count is limited, the search works almost well.
     */
    get: operations["groupsJoinableSearch"];
  };
  "/current-user/check-login-id": {
    /** Checks if a given `{login_id}` matches the one of the current user. */
    get: operations["loginIDCheck"];
  };
  "/current-user/dump": {
    /**
     * Returns a downloadable JSON file with all the short version of the current user's data. The content returned is just the dump of raw entries of tables related to the user
     *
     *   * `current_user` (from `users`): all attributes;
     *   * `managed_groups`: `id` and `name` for every descendant of groups managed by the user;
     *   * `joined_groups`: `id` and `name` for every ancestor of user’s `group_id`;
     *   * `groups_groups`: where the user’s `group_id` is the `child_group_id`, all attributes + `groups.name`;
     *   * `group_managers`: where the user’s `group_id` is the `manager_id`, all attributes + `groups.name`;
     *
     * In case of unexpected error (e.g. a DB error), the response will be a malformed JSON like ```{"current_user":{"success":false,"message":"Internal Server Error","error_text":"Some error"}```
     */
    get: operations["currentUserDataExport"];
  };
  "/current-user/dump-full": {
    /**
     * Returns a downloadable JSON file with all the current user's data. The content returned is just the dump of raw entries of each table related to the user
     *
     *   * `current_user` (from `users`): all attributes;
     *   * `sessions`, `refresh_token`: all attributes, but secrets replaced with “***”;
     *   * `managed_groups`: `id` and `name` for every descendant of groups managed by the user;
     *   * `joined_groups`: `id` and `name` for every ancestor of user’s `group_id`;
     *   * `answers`: all attributes;
     *   * `attempts`: the user's or his teams' attempts, all attributes;
     *   * `results`: the user's or his teams' attempt results, all attributes;
     *   * `groups_groups`: where the user’s `group_id` is the `child_group_id`, all attributes + `groups.name`;
     *   * `group_managers`: where the user’s `group_id` is the `manager_id`, all attributes + `groups.name`;
     *   * `group_pending_requests`: where the user’s `group_id` is the `member_id`, all attributes + `groups.name`;
     *   * `group_membership_changes`: where the user’s `group_id` is the `member_id`, all attributes + `groups.name`.
     *
     * In case of unexpected error (e.g. a DB error), the response will be a malformed JSON like ```{"current_user":{"success":false,"message":"Internal Server Error","error_text":"Some error"}```
     */
    get: operations["currentUserFullDataExport"];
  };
  "/current-user/group-invitations": {
    /** Returns the list of invitations that the current user received and requests sent by him (`group_membership_changes.action` is “invitation_created” or “join_request_created” or “join_request_refused”) with `group_membership_changes.at` within `within_weeks` back from now (if `within_weeks` is present). */
    get: operations["invitationsView"];
  };
  "/current-user/group-invitations/{group_id}/accept": {
    /**
     * Lets the current user approve an invitation to join a group (idenfified by {group_id}). On success the service creates a new `groups_groups` row with `parent_group_id` = `group_id` and `child_group_id` = `user.group_id`, and a new `group_membership_changes` row with `action` = 'invitation_accepted' (the `at` field of both rows is set to current UTC time). The invitation gets removed from `group_pending_requests`. The service also refreshes the access rights.
     * * If the group is a team and the user is already on a team that has attempts for same contest while the contest doesn't allow multiple attempts or that has active attempts for the same contest, or if the group membership is frozen, the unprocessable entity error is returned.
     * * If the group is a team and joining breaks entry conditions of at least one of the team's participations (i.e. any of `entry_min_admitted_members_ratio` or `entry_max_team_size` would not be satisfied), the unprocessable entity error is returned.
     * * There should be a row in `group_pending_requests` with the `{group_id}` as a parent as `group_id` and the authenticated user’s `group_id` as `member_id` with `type`='invitation'. Otherwise the "not found" error is returned.
     * * If some of approvals required by the group are missing in `approvals`, the unprocessable entity error is returned with a list of missing approvals.
     * * If the group doesn't exist or is a user, or if the current user is temporary, the "forbidden" response is returned.
     */
    post: operations["groupInvitationAccept"];
  };
  "/current-user/group-invitations/{group_id}/reject": {
    /**
     * Lets the current user reject an invitation to join a group (identified by {group_id}). On success the service removes a `groups_pending_request` row with `group_id` = `{group_id}` and `member_id` = `user.group_id`, and adds a new `group_membership_changes` row with `action` = 'invitation_refused' and `at` = current UTC time.
     * * There should be a row in `group_pending_requests` with the `{group_id}` as `group_id` and the authenticated user’s `group_id` as `member_id` with `type`=`invitation_created`. Otherwise the unprocessable entity error is returned.
     */
    post: operations["groupInvitationReject"];
  };
  "/current-user/group-leave-requests/{group_id}": {
    /**
     * Lets the current user create a request to leave a group (idenfified by {group_id}).
     *
     * On success the service creates a new row in `group_pending_requests` with `group_id` = `{group_id}` `type` = 'leave_request' and `member_id` = user's `group_id` + a new row in `group_membership_changes` with `action` = `leave_request_created` and `at` equal to current UTC time.
     *
     * If there is already a row in `groups_groups` and a row in `group_pending_request` with `type` == 'leave_request', the "unchanged" (201) response is returned.
     *
     * The user should be a member of the `{group_id}` and the group's `require_lock_membership_approval_until` should be greater than NOW(), and `groups_groups.lock_membership_approved` should be set, and the group membership should not be frozen. Otherwise the "forbidden" error is returned.
     */
    post: operations["groupLeaveRequestCreate"];
  };
  "/current-user/group-leave-requests/{group_id}/withdraw": {
    /**
     * Lets the current user withdraw a request to leave a group (idenfified by {group_id}).
     *
     * On success the service removes a row  with `group_id` = `{group_id}`, `type` = 'leave_request' and `member_id` = user's `group_id` from the `group_pending_requests` table and creates a new row in `group_membership_changes` with `action` = `leave_request_withdrawn` and `at` equal to current UTC time.
     *
     * The user should be a member of the group and there should be a row with `type` = 'leave_request', `group_id` = `{parent_group_id}` and `member_id` = user's `group_id` in `group_pending_requests`, otherwise the "not found" error is returned.
     */
    post: operations["groupLeaveRequestWithdraw"];
  };
  "/current-user/group-memberships": {
    /** Returns the list of groups memberships of the current user. */
    get: operations["membershipsView"];
  };
  "/current-user/group-memberships-history": {
    /** Returns the records from `group_membership_changes` having `at` >= `users.notifications_read_at` and any user-related type (`action` != "added_directly") with the corresponding `groups` for the current user. */
    get: operations["groupsMembershipHistory"];
  };
  "/current-user/group-memberships/{group_id}": {
    /**
     * Lets a user to leave a group. On success the service removes a row with with `parent_group_id` = `group_id` and `child_group_id` = `user.group_id` from `groups_groups`, and adds a new `group_membership_changes` row with `action` = 'left' and `at` = current UTC time. It also refreshes the access rights.
     * * There should be a row in `groups_groups` with the `group_id` as a parent and the authenticated user’s `id` as a child. Otherwise the "not found" error is returned.
     * * The user cannot leave the group if `NOW()` < `groups.require_lock_membership_approval_until` and `groups_groups.lock_membership_approved` is set or if the group membership is frozen or if the group is a 'Base' group. Otherwise the "forbidden" error is returned.
     * * If the group is a team and leaving breaks entry conditions of at least one of the team's participations (i.e. any of `entry_min_admitted_members_ratio` or `entry_max_team_size` would not be satisfied), the unprocessable entity error is returned.
     */
    delete: operations["groupLeave"];
  };
  "/current-user/group-memberships/activities": {
    /**
     * If `{watched_group_id}` is not given, the service returns the list of root activities of the groups the current user (or `{as_team_id}`) belongs to. Otherwise, the service returns the list of root activities (visible to the current user or `{as_team_id}`) of all ancestor groups of the watched group which are also ancestors or descendants of at least one group that the current user manages explicitly. Permissions returned for activities are related to the current user (or `{as_team_id}`). Only one of `{as_team_id}` and `{watched_group_id}` can be given.
     *
     * If `{as_team_id}` is given, it should be a user's parent team group, otherwise the "forbidden" error is returned.
     *
     * If `{watched_group_id}` is given, the user should ba a manager (implicitly) of the group with the 'can_watch_members' permission, otherwise the "forbidden" error is returned.
     */
    get: operations["activitiesView"];
  };
  "/current-user/group-memberships/by-code": {
    /**
     * Lets a user to join a group by a code. On success the service inserts a row into `groups_groups` with `parent_group_id` = `id` of the group found by the code and `child_group_id` = `group_id` of the user and another row into `group_membership_changes` with `group_id` = `id` of the group, `member_id` = `group_id` of the user, `action`=`joined_by_code`, and `at` = current UTC time. It also refreshes the access rights.
     * * If there is no group with `code_expires_at` > NOW() (or NULL), `code` = `{code}`, and `type` != 'User' or if the current user is temporary, the forbidden error is returned.
     * * If the group is a team and the user is already on a team that has attempts for same contest while the contest doesn't allow multiple attempts or that has active attempts for the same contest, or if the group membership is frozen, the unprocessable entity error is returned.
     * * If there is already a row in `groups_groups` with the found group as a parent and the authenticated user’s selfGroup’s id as a child, the unprocessable entity error is returned.
     * * If the group is a team and joining breaks entry conditions of at least one of the team's participations (i.e. any of `entry_min_admitted_members_ratio` or `entry_max_team_size` would not be satisfied), the unprocessable entity error is returned.
     * * If the group requires some approvals from the user and those are not given in `approval`, the unprocessable entity error is returned with a list of missing approvals.
     * * If `groups.enforce_max_participants` is true and the number of participants >= `groups.max_participants`, the conflict error is returned. (The number of participants is computed as the number of non-expired users or teams which are direct children of the group + invitations (join requests are not counted)).
     */
    post: operations["groupsJoinByCode"];
  };
  "/current-user/group-memberships/skills": {
    /**
     * If `{watched_group_id}` is not given, the service returns the list of root skills of the groups the current user (or `{as_team_id}`) belongs to. Otherwise, the service returns the list of root skills (visible to the current user or `{as_team_id}`) of all ancestor groups of the watched group which are also ancestors or descendants of at least one group that the current user manages explicitly. Permissions returned for skills are related to the current user (or `{as_team_id}`). Only one of `{as_team_id}` and `{watched_group_id}` can be given.
     *
     * If `{as_team_id}` is given, it should be a user's parent team group, otherwise the "forbidden" error is returned.
     *
     * If `{watched_group_id}` is given, the user should ba a manager (implicitly) of the group with the 'can_watch_members' permission, otherwise the "forbidden" error is returned.
     */
    get: operations["skillsView"];
  };
  "/current-user/group-requests/{group_id}": {
    /**
     * Lets the current user create a request to join a group (idenfified by {group_id}). There are two possible cases:
     * #### The user is not a manager of the group
     *
     *   On success the service creates a new row in `group_pending_requests` with
     *   `group_id` = `{group_id}`, `member_id` = user's self group id, `type` = 'join_request',
     *   given `approvals` and `at` equal to current UTC time,
     *   and a new row in `group_membership_changes` for the same pair of groups
     *   with `action` = 'join_request_created' and `at` equal to current UTC time.
     *
     *   * `groups.is_public` should be 1, otherwise the 'forbidden' response is returned.
     *
     *   * If there is already a row in `group_pending_requests` with
     *     `type` != 'join_request' or a row in `groups_groups` for the same group-user pair,
     *     the unprocessable entity error is returned.
     *
     *   * If there is already a row in `group_pending_requests` with `type` = 'join_request',
     *     the "unchanged" (201) response is returned.
     *
     * #### The user is a manager of the group with `can_manage` >= 'memberships'
     *
     *   On success the service creates a new row in `groups_groups` with `parent_group_id` = `group_id`,
     *   given `approvals` and `child_group_id` = user's self group id + a new row in `group_membership_changes`
     *   for the same group pair with `action` = `join_request_accepted` and `at` equal to current UTC time.
     *   A pending request/invitation gets removed from `group_pending_requests`.
     *
     *   * If there is already a row in `groups_groups` or a row in `group_pending_request` with
     *     `type` != 'invitation'/'join_request', the unprocessable entity error is returned.
     *
     *   On success, the service propagates group ancestors in this case.
     *
     *
     * In both cases, if some approvals required by the group are missing in `approvals`, the unprocessable entity error with a list of missing approvals is returned.
     *
     * If the group doesn't exist, or it is a user, or its membership is frozen, or the current user is a temporary user, the "forbidden" response is returned.
     *
     * If the group is a team and the user is already on a team that has attempts for same contest while the contest doesn't allow multiple attempts or that has active attempts for the same contest, the unprocessable entity error is returned.
     *
     * If the group is a team and joining breaks entry conditions of at least one of the team's participations (i.e. any of `entry_min_admitted_members_ratio` or `entry_max_team_size` would not be satisfied), the unprocessable entity error is returned.
     *
     * If `groups.enforce_max_participants` is true and the number of participants >= `groups.max_participants`, the conflict error is returned. (The number of participants is computed as the number of non-expired users or teams which are direct children
     *  of the group + invitations (join requests are not counted)).
     */
    post: operations["groupJoinRequestCreate"];
  };
  "/current-user/group-requests/{group_id}/withdraw": {
    /**
     * Lets the current user withdraw a request to join a group (idenfified by {group_id}).
     *
     * On success the service removes a row  with `group_id` = `{group_id}`, `member_id` = user's self group id and `type` = 'join_request' from the `group_pending_requests` table, and creates a new row in `group_membership_changes` for the same group-user pair with `action` = 'join_request_withdrawn' and `at` equal to current UTC time.
     * * If there is no row in `group_pending_requests` for the group-user pair with
     *   `type` == 'join_request', the "not found" error is returned.
     */
    post: operations["groupJoinRequestWithdraw"];
  };
  "/current-user/managed-groups": {
    /** Returns groups for which the current user is a manager (subgroups are skipped) */
    get: operations["managedGroupsView"];
  };
  "/current-user/notifications-read-at": {
    /** Set users.notifications_read_at to NOW() for the current user */
    put: operations["userNotificationReadDateUpdate"];
  };
  "/current-user/refresh": {
    /** Gets the user info from the login module and updates the local user info cache stored in the `users` table */
    put: operations["userDataRefresh"];
  };
  "/current-user/teams/by-item/{item_id}": {
    /**
     * The team identified by `{item_id}` i.e. a group which:
     *
     *   * has an active and unexpired attempt with `root_item_id` = `{item_id}`,
     *
     *   * is a direct parent (i.e. via `groups_groups`) of the authenticated user’s `selfGroup`,
     *
     *   * is of type "Team".
     *
     *
     * If there are several matching teams, returns the first one in the order of `groups.id`.
     */
    get: operations["teamGetByItemID"];
  };
  "/groups": {
    /**
     * Creates a group with the input `name`, `type`, `created_at` = now(), and default values in other columns.
     *
     * Also, the service sets the authenticated user as a manager of the group with the highest level of permissions. After everything, it propagates group ancestors.
     *
     * The user should not be temporary, otherwise the "forbidden" response is returned.
     */
    post: operations["groupCreate"];
  };
  "/groups/{group_id}": {
    /**
     * Returns the group identified by the given `group_id`.
     *
     * The `group_id` group should be visible to the current user, so it should be either an ancestor of a group he joined, or an ancestor of a non-user group he manages, or a descendant of a group he manages, or a public group, otherwise the 'forbidden' error is returned. If the group is a user, the 'forbidden' error is returned as well.
     *
     * Note: `code*` and `current_user_can_*` fields are omitted when the user is not a manager of the group.
     */
    get: operations["groupGet"];
    /**
     * Updates group information.
     * Requires the user to be a manager of the group, otherwise the 'forbidden' error is returned.
     *
     * The user should have `can_manage` >= 'memberships' in order to modify `code_expires_at`, `code_lifetime`, `frozen_membership`, `max_participants`, or `enforce_max_participants`, otherwise the "bad request" error is returned. In order to modify values of other fields, the user should have `can_manage` >= 'memberships_and_group'.
     *
     * If the `root_activity_id` item is provided and is not null, the item should not be a skill and the user should have at least 'can_view:info' permission on it, otherwise the 'forbidden' error is returned.
     *
     * If the `root_skill_id` item is provided and is not null, the item should be a skill and the user should have at least 'can_view:info' permission on it, otherwise the 'forbidden' error is returned.
     *
     * If `is_official_session` is being changed to true, the user should have at least 'can_make_session_official' permission on the activity item, otherwise the 'forbidden' error is returned.
     *
     * Setting `is_official_session` to true while keeping `root_activity_id` not set or setting `root_activity_id` to null for an official session will cause the "bad request" error.
     *
     * Setting `enforce_max_participants` to true while keeping `max_participants` null or setting `max_participants` to null while keeping `enforce_max_participants` = true will cause the "bad request" error.
     *
     * Changing `require_personal_info_access_approval` to 'edit' will cause the "bad request" error.
     */
    put: operations["groupUpdate"];
    /**
     * Removes a group, its parent-child relations and other objects linked to it.
     *
     * The service deletes `groups_groups`, `attempts`, `results`, `group_membership_changes`, `group_pending_requests`, `permissions_granted`, `permissions_generated`, and `filters` linked to the group. Access rights are updated accordingly too.
     *
     * Restrictions (otherwise the 'forbidden' error is returned):
     *   * the authenticated user should be a manager with `can_manage` = 'memberships_and_group' on the `{group_id}`,
     *   * the group should not be of type "User".
     *
     * Also, the group must be empty (no active subgroups of any type), otherwise the 'not found' error is returned.
     */
    delete: operations["groupDelete"];
  };
  "/groups/{group_id}/children": {
    /**
     * Returns visible children of the group having types specified by `types_include` and `types_exclude` parameters.
     *
     * A group is visible if it is either 1) an ancestor of a group the current user joined, or 2) an ancestor of a non-user group he manages, or 3) a descendant of a group he manages, or 4) a public group.
     *
     * * The `group_id` should be visible to the current user.
     *
     * Note: `user_count` and `current_user_can_*` fields are omitted when the user is not a manager of the group.
     */
    get: operations["groupChildrenView"];
  };
  "/groups/{group_id}/code": {
    /**
     * Creates a new code using a set of allowed characters [3456789abcdefghijkmnpqrstuvwxy]. Makes sure it doesn’t correspond to any existing group code. Saves it for the given group and returns it.
     *
     * The authenticated user should be a manager of `group_id` with `can_manage` >= 'memberships', otherwise the 'forbidden' error is returned. If the group is a user, the 'forbidden' error is returned as well.
     */
    post: operations["groupCodeCreate"];
    /**
     * Removes the code of the given group (which prevents joining by code)
     *
     * The authenticated user should be a manager of `group_id` with `can_manage` >= 'memberships', otherwise the 'forbidden' error is returned. If the group is a user, the 'forbidden' error is returned as well.
     */
    delete: operations["groupCodeRemove"];
  };
  "/groups/{group_id}/granted_permissions": {
    /**
     * List all permissions granted to a group and its ancestors or to its descendants. Only permissions granted on items for which the current user has `can_grant_view` > 'none' or `can_watch` = 'answer_with_grant' or `can_edit` = 'all_with_grant' are displayed.
     *
     * When `{descendants}` is 0, source groups of permissions are ancestors of the `group_id` group (including the group itself) managed by the current user with `can_grant_group_access` permission.
     * When `{descendants}` is 1, source groups of permissions are ancestors of the `group_id` group (including the group itself) or descendants of the `group_id` group managed by the current user with `can_grant_group_access` permission.
     * * The current user must be a manager (with `can_grant_group_access` permission) of `{group_id}`.
     */
    get: operations["grantedPermissionsView"];
  };
  "/groups/{group_id}/group-progress": {
    /**
     * Returns the current progress of a group on a subset of items.
     *
     * For each item from `{parent_item_id}` and its visible children, displays the result of each direct child of the given `group_id` whose type is not in (Team, User).
     *
     * Restrictions:
     * * The current user should be a manager of the group (or of one of its ancestors) with `can_watch_members` set to true,
     * * The current user should have `can_watch_members` >= 'result' on each of `{parent_item_ids}` items,
     *
     * otherwise the 'forbidden' error is returned.
     */
    get: operations["groupGroupProgress"];
  };
  "/groups/{group_id}/group-progress-csv": {
    /**
     * Returns the current progress of a group on a subset of items.
     *
     * For each item from `{parent_item_id}` and its visible children, displays the average result of each direct child of the given `group_id` whose type is not in (Team, User).
     *
     * Restrictions:
     * * The current user should be a manager of the group (or of one of its ancestors) with `can_watch_members` set to true,
     * * The current user should have `can_watch_members` >= 'result' on each of `{parent_item_ids}` items,
     *
     * otherwise the 'forbidden' error is returned.
     */
    get: operations["groupGroupProgressCSV"];
  };
  "/groups/{group_id}/managers": {
    /**
     * Lists managers of the given group and (optionally) managers of its ancestors (rows from the `group_managers` table with `group_id` = `{group_id}`) including managers' names.
     *
     * The authenticated user should be a manager of the `group_id` group or a member of the group or of its descendant, otherwise the 'forbidden' error is returned.
     */
    get: operations["groupManagersView"];
  };
  "/groups/{group_id}/managers/{manager_id}": {
    /**
     * Modifies permissions of a group manager.
     *
     * The authenticated user should have 'can_manage:memberships_and_group' permission on the group and the `{group_id}`-`{manager_id}` pair should exist in `group_managers, otherwise the "forbidden" error is returned.
     */
    put: operations["groupManagerEdit"];
    /**
     * Makes a user a group manager with given permissions.
     *
     * The authenticated user should have 'can_manage:memberships_and_group' permission on the group and `{manager_id}` should exist, otherwise the "forbidden" error is returned.
     */
    post: operations["groupManagerCreate"];
    /**
     * Removes a group manager.
     *
     * The authenticated user should be the manager represented by `{manager_id}` or have 'can_manage:memberships_and_group' permission on the group and the `{group_id}`-`{manager_id}` pair should exist in `group_managers, otherwise the "forbidden" error is returned.
     */
    delete: operations["groupManagerDelete"];
  };
  "/groups/{group_id}/members": {
    /**
     * Returns a list of users that are members of the group. The output contains basic user info (`first_name` and `last_name` are only shown for the authenticated user or if the user approved access to their personal info for some group managed by the authenticated user).
     *
     * The authenticated user should be a manager of `{group_id}`, otherwise the 'forbidden' error is returned.
     */
    get: operations["groupsMembersView"];
    /**
     * Lets an admin remove users from a group. On success the service removes relations from `groups_groups` and creates `group_membership_changes` rows with `action` = 'removed and `at` = current UTC time for each of `user_ids`. It also refreshes the access rights.
     *
     * The authenticated user should be a manager of the `group_id` with `can_manage` >= 'memberships', otherwise the 'forbidden' error is returned. If the group is a user, the 'forbidden' error is returned as well.
     *
     * Each of the input `user_ids` should have the input `group_id` as a parent in `groups_groups`, otherwise the `user_id` gets skipped with `invalid` as the result.
     *
     * The response status code on success (200) doesn't depend on per-group results.
     */
    delete: operations["groupRemoveMembers"];
  };
  "/groups/{group_id}/navigation": {
    /**
     * Lists child groups visible to the user, so either 1) ancestors of a group he joined, or 2) ancestors of a non-user group he manages, or 3) descendants of a group he manages, or 4) groups with `is_public` = 1. Ordered alphabetically by name.
     *
     * The input group should be visible to the current user with the same definition as above, otherwise the 'forbidden' error is returned. If the group is a user, the 'forbidden' error is returned as well.
     */
    get: operations["groupNavigationView"];
  };
  "/groups/{group_id}/path-from-root": {
    /**
     * Finds a path from any of root groups to a given group.
     *
     * A path is an array of group ids from a visible group root (a visible non-"base" group without non-"base" parent) to the input group. Each group must be visible, so either 1) ancestors of groups he joined, 2) ancestors of non-user groups he manages, 3) descendants of groups he manages, 4) groups with is_public=1. Of all possible paths the service chooses any of shortest ones.
     *
     * At least one path should exist, otherwise the 'forbidden' error is returned.
     */
    get: operations["groupPathFromRootFind"];
  };
  "/groups/{group_id}/requests": {
    /**
     * Returns a list of group requests and invitations (rows from the `group_membership_changes` table with `group_id` = `{group_id}` and `action` = "invitation_created"/"join_request_created"/"invitation_refused"/"join_request_refused") with basic info on joining (invited/requesting) users and inviting users.
     *
     * When `old_rejections_weeks` is given, only those rejected invitations/requests (`group_membership_changes.action` is "invitation_refused" or "join_request_refused") are shown that are created in the last `old_rejections_weeks` weeks. Otherwise all rejected invitations/requests are shown.
     *
     * `first_name` and `last_name` are only shown for joining users whose personal info is visible to the current user. A user can see personal info of his own and of those members/candidates of his managed groups who have provided view access to their personal data.
     *
     * Inviting users are displayed only if `group_membership_changes.action` = "invitation_created".
     *
     * The authenticated user should be a manager of `group_id` with `can_manage` >= 'memberships', otherwise the 'forbidden' error is returned. If the group is a user, the 'forbidden' error is returned as well.
     */
    get: operations["groupRequestsView"];
  };
  "/groups/{group_id}/team-descendants": {
    /**
     * Returns all teams (`type` = "Team") among the descendants of the given group
     *
     * `first_name` and `last_name` of descendant team members are only visible to the members themselves and to managers of those groups to which those members provided view access to personal data.
     *
     * * The authenticated user should be a manager of the parent group.
     */
    get: operations["groupTeamDescendantView"];
  };
  "/groups/{group_id}/team-progress": {
    /**
     * Returns the current progress of teams on a subset of items.
     *
     * For each item from `{parent_item_id}` and its visible children, displays the result of each team among the descendants of the group.
     *
     * Restrictions:
     * * The current user should be a manager of the group (or of one of its ancestors) with `can_watch_members` set to true,
     * * The current user should have `can_watch_members` >= 'result' on each of `{parent_item_ids}` items,
     *
     * otherwise the 'forbidden' error is returned.
     */
    get: operations["groupTeamProgress"];
  };
  "/groups/{group_id}/team-progress-csv": {
    /**
     * Returns the current progress of teams on a subset of items.
     *
     * For each item from `{parent_item_id}` and its visible children, displays the result of each team among the descendants of the group.
     *
     * Restrictions:
     * * The current user should be a manager of the group (or of one of its ancestors) with `can_watch_members` set to true,
     * * The current user should have `can_watch_members` >= 'result' on each of `{parent_item_ids}` items,
     *
     * otherwise the 'forbidden' error is returned.
     */
    get: operations["groupTeamProgressCSV"];
  };
  "/groups/{group_id}/user-batch-prefixes": {
    /**
     * Lists the user-batch prefixes  with `allow_new` = 1 matching the input group's ancestors that are managed by the current user with 'can_manage:membership' permission (i.e., the `group_id` is a descendant of `user_batch_prefixes.group_id`).
     *
     * The authenticated user should be a manager of `group_id` with 'can_manage:membership' permission at least, otherwise the 'forbidden' error is returned. If the group is a user, the 'forbidden' error is returned as well.
     */
    get: operations["userBatchPrefixesView"];
  };
  "/groups/{group_id}/user-descendants": {
    /**
     * Return all users (`type` = "User") among the descendants of the given group
     *
     * `first_name` and `last_name` of descendant users are only visible to the users themselves and to managers of those groups to which those users provided view access to personal data.
     *
     * * The authenticated user should be a manager of the parent group.
     */
    get: operations["groupUserDescendantView"];
  };
  "/groups/{group_id}/user-progress": {
    /**
     * Returns the current progress of users on a subset of items.
     *
     * For each item from `{parent_item_id}` and its visible children, displays the result of all user self-groups among the descendants of the given group (including those in teams).
     *
     * For each user, only the result corresponding to his best score counts (across all his teams and his own results) disregarding whether or not the score was done in a team which is descendant of the input group.
     *
     * Restrictions:
     * * The current user should be a manager of the group (or of one of its ancestors) with `can_watch_members` set to true,
     * * The current user should have `can_watch` >= 'result' on each of `{parent_item_ids}` items,
     *
     * otherwise the 'forbidden' error is returned.
     */
    get: operations["groupUserProgress"];
  };
  "/groups/{group_id}/user-progress-csv": {
    /**
     * Returns the current progress of users on a subset of items.
     *
     * For each item from `{parent_item_id}` and its visible children, displays the result of all user self-groups among the descendants of the given group (including those in teams).
     *
     * For each user, only the result corresponding to his best score counts (across all his teams and his own results) disregarding whether or not the score was done in a team which is descendant of the input group.
     *
     * Restrictions:
     * * The current user should be a manager of the group (or of one of its ancestors) with `can_watch_members` set to true,
     * * The current user should have `can_watch` >= 'result' on each of `{parent_item_ids}` items,
     *
     * otherwise the 'forbidden' error is returned.
     */
    get: operations["groupUserProgressCSV"];
  };
  "/groups/{ids}/breadcrumbs": {
    /**
     * Returns brief information for groups listed in `ids`.
     *
     * Each group must be visible to the current user, so it should be either
     *
     *   1. an ancestor of a group the current user joined, or
     *   2. an ancestor of a non-user group he manages, or
     *   3. a descendant of a group he manages, or
     *   4. a group with is_public=1,
     *
     * otherwise the 'forbidden' error is returned. Also, there must be no duplicates in the list.
     */
    get: operations["groupBreadcrumbsView"];
  };
  "/groups/{parent_group_id}/invitations": {
    /**
     * Lets an admin invite users, based on list of their logins, to join a group (identified by {parent_group_id}). On success the service creates new rows in `group_pending_requests` with
     * * `type` = "invitation"
     * * `at` = current UTC time
     * and `group_membership_changes` with
     * * `action` = "invitation_created"
     * * `at` = current UTC time.
     * * `initiator_id` = `users.group_id` of the authorized user.
     *
     * It also refreshes the access rights when needed.
     *
     * * Logins not corresponding to valid users or corresponding to temporary users are ignored (result = "not_found").
     * * If the `parent_group_id` corresponds to a team, the service skips users who are members of other teams participating in same contests as `parent_group_id` (expired/ended attempts are ignored for contests allowing multiple attempts, result = "in_another_team").
     * * Pending group requests from users listed in `logins` become accepted (result = "success") if all needed approvals are given, or replaced by invitations otherwise.
     * * Pending invitations stay unchanged (result = "unchanged).
     * * Group members (already having `groups_groups`) are skipped (result = "invalid").
     *
     * The action should not create cycles in the groups relations graph, otherwise the login gets skipped with `cycle` as the result.
     *
     * If `groups.enforce_max_participants` is true and the new number of participants exceeds `groups.max_participants`, all the valid logins get skipped with `full` as the result. (The number of participants is computed as the number of non-expired users or teams which are direct children of the group + invitations (join requests are not counted)).
     *
     * The response status code on success (201) doesn't depend on per-group results.
     *
     * The authenticated user should be a manager of the `parent_group_id` with `can_manage` >= 'memberships', otherwise the 'forbidden' error is returned. If the group is a user, the 'forbidden' error is returned as well.
     */
    post: operations["groupInvitationsCreate"];
  };
  "/groups/{parent_group_id}/invitations/withdraw": {
    /**
     * Lets a manager withdraw invitations (of users with ids in {group_ids}) to join a group (idenfified by {parent_group_id}). On success the service removes rows with `type` = 'invitation' from `group_pending_requests` and creates new rows with `action` = 'invitation_withdrawn' and `at` = current UTC time in `group_membership_changes` for each of `group_ids`.
     *
     * The authenticated user should be a manager of the `parent_group_id` with `can_manage` >= 'memberships', otherwise the 'forbidden' error is returned. If the group is a user, the 'forbidden' error is returned as well.
     *
     * There should be a row with `type` = 'invitation' and `group_id` = `{parent_group_id}` in `group_pending_requests` for each of the input `group_ids`, otherwise the `group_id` gets skipped with `invalid` as the result.
     *
     * The response status code on success (200) doesn't depend on per-group results.
     */
    post: operations["groupInvitationsWithdraw"];
  };
  "/groups/{parent_group_id}/join-requests/accept": {
    /**
     * Lets an admin approve user requests (identified by `{group_ids}`) to join a group (identified by {parent_group_id}). On success the service creates new `groups_groups` rows with `parent_group_id` = `{parent_group_id}` and new `group_membership_changes` with `group_id` = `{parent_group_id}`, `action` = 'join_request_accepted`, `at` = current UTC time for each of `group_ids`. The `groups_groups.*_approved_at` fields are set to `group_pending_requests.at` for each approval given in the pending join requests. Then the appropriate pending requests get removed from `group_pending_requests`. The service also refreshes the access rights.
     *
     * The authenticated user should be a manager of the `{parent_group_id}` with `can_manage` >= 'memberships', otherwise the 'forbidden' error is returned. If the group is a user or if the group membership is frozen, the 'forbidden' error is returned as well.
     *
     * If the `{parent_group_id}` corresponds to a team, `{group_ids}` can contain no more than one id, otherwise the 'bad request' response is returned.
     *
     * If the `{parent_group_id}` corresponds to a team, the service skips a user being a member of another team having attempts for the same contest as `{parent_group_id}` (expired attempts are ignored for contests allowing multiple attempts, result = "in_another_team").
     *
     * If the `{parent_group_id}` corresponds to a team, the service skips a user with result = "in_another_team" if joining breaks entry conditions of at least one of the team's participations (i.e. any of `entry_min_admitted_members_ratio` or `entry_max_team_size` would not be satisfied).
     *
     * There should be a row with `type` = 'join_request' and `group_id` = `{parent_group_id}` in `group_pending_requests` for each of the input `group_ids`, otherwise the `group_id` gets skipped with 'invalid' as the result.
     *
     * If the `{parent_group_id}` requires any approvals, but the pending request doesn't contain them, the `group_id` gets skipped with 'approvals_missing' as the result.
     *
     * The action should not create cycles in the groups relations graph, otherwise the `group_id` gets skipped with `cycle` as the result.
     *
     * If `groups.enforce_max_participants` is true and the new number of participants exceeds `groups.max_participants` for the `{parent_group_id}` group, all the valid joining groups get skipped with `full` as the result. (The number of participants is computed as the number of non-expired users or teams which are direct children of the group + invitations (join requests are not counted)).
     *
     * The response status code on success (200) doesn't depend on per-group results.
     */
    post: operations["groupJoinRequestsAccept"];
  };
  "/groups/{parent_group_id}/join-requests/reject": {
    /**
     * Lets an admin reject requests (of users with ids in {group_ids}) to join a group (identified by {parent_group_id}). On success the service removes rows with `type` = 'join_request' from `group_pending_requests` and creates new rows with `action` = 'join_request_refused' and `at` = current UTC time in `group_membership_changes` for each of `group_ids`.
     *
     * The authenticated user should be a manager of the `parent_group_id` with `can_manage` >= 'memberships', otherwise the 'forbidden' error is returned. If the group is a user, the 'forbidden' error is returned as well.
     *
     * There should be a row with `type` = 'join_request' and `group_id` = `{parent_group_id}` in `group_pending_requests` for each of the input `group_ids`, otherwise the `group_id` gets skipped with `invalid` as the result.
     *
     * The response status code on success (200) doesn't depend on per-group results.
     */
    post: operations["groupJoinRequestsReject"];
  };
  "/groups/{parent_group_id}/leave-requests/accept": {
    /**
     * Lets an admin approve user requests (identified by `{group_ids}`) to leave a group (identified by {parent_group_id}). On success the service removes `groups_groups` rows with `parent_group_id` = `{parent_group_id}` and creates new `group_membership_changes` with `group_id` = `{parent_group_id}`, `action` = 'leave_request_accepted`, `at` = current UTC time for each of `group_ids` The appropriate pending requests get removed from `group_pending_requests`. The service also refreshes the access rights.
     *
     * The authenticated user should be a manager of the `{parent_group_id}` with `can_manage` >= 'memberships', otherwise the 'forbidden' error is returned.  If the group is a user or the group membership is frozen, the 'forbidden' error is returned as well.
     *
     * There should be a row with `type` = 'leave_request' and `group_id` = `{parent_group_id}` in `group_pending_requests` for each of the input `group_ids`, otherwise the `group_id` gets skipped with `invalid` as the result.
     *
     * If the `{parent_group_id}` corresponds to a team, `{group_ids}` can contain no more than one id, otherwise the 'bad request' response is returned.
     *
     * If the `{parent_group_id}` corresponds to a team, the service skips a user with result = "in_another_team" if removal breaks entry conditions of at least one of the team's participations (i.e. any of `entry_min_admitted_members_ratio` or `entry_max_team_size` would not be satisfied).
     *
     * The response status code on success (200) doesn't depend on per-group results.
     */
    post: operations["groupLeaveRequestsAccept"];
  };
  "/groups/{parent_group_id}/leave-requests/reject": {
    /**
     * Lets an admin reject requests (of users with ids in {group_ids}) to leave a group (identified by {parent_group_id}). On success the service removes rows with `type` = 'leave_request' from `group_pending_requests` and creates new rows with `action` = 'leave_request_refused' and `at` = current UTC time in `group_membership_changes` for each of `group_ids`.
     *
     * The authenticated user should be a manager of the `parent_group_id` with `can_manage` >= 'memberships', otherwise the 'forbidden' error is returned. If the group is a user, the 'forbidden' error is returned as well.
     *
     * There should be a row with `type` = 'leave_request' and `group_id` = `{parent_group_id}` in `group_pending_requests` for each of the input `group_ids`, otherwise the `group_id` gets skipped with `invalid` as the result.
     *
     * The response status code on success (200) doesn't depend on per-group results.
     */
    post: operations["groupLeaveRequestsReject"];
  };
  "/groups/{parent_group_id}/relations/{child_group_id}": {
    /**
     * Add a group as a child to another group. Lets a group admin add another group as a child and refreshes the access rights afterwards.
     *
     * Restrictions (otherwise the 'forbidden' error is returned):
     *   * the authenticated user should be a manager of both `parent_group_id` and `child_group_id,
     *   * the authenticated user should have `can_manage` >= 'memberships' on the `parent_group_id`,
     *   * the authenticated user should have `can_manage` = 'memberships_and_group' on the `child_group_id`,
     *   * the parent group should not be of type "User" or "Team",
     *   * the child group should not be of types "Base" or "User"
     *     (since users should join groups only by code or by invitation/request),
     *   * the action should not create cycles in the groups relations graph.
     */
    post: operations["groupAddChild"];
    /**
     * Removes a child group from a parent group and optionally deletes that group and its subgroups.
     *
     * Deletes the relation from `groups_groups`. If `{delete_orphans}` is true and the child group becomes an orphan then the service also deletes that group, its parent-child relations, and recursively deletes each new orphaned group.
     *
     * If `{delete_orphans}` is false and the child removal makes it an orphan (it doesn't have other parent groups), the service deletes the relation keeping the orphaned child group.
     *
     * If a group gets deleted, the service also deletes `groups_groups`, `attempts`, `results`, `group_membership_changes`, `group_pending_requests`, `permissions_granted`, `permissions_generated`, and `filters` linked to the group. Access rights are updated accordingly too.
     *
     * Restrictions (otherwise the 'forbidden' error is returned):
     *   * the authenticated user should be a manager of both `{parent_group_id}` and `{child_group_id}`,
     *   * the authenticated user should have `can_manage` >= 'memberships' on the `{parent_group_id}`,
     *   * the parent group should not be of type "User" or "Team",
     *   * the child group should not be of types "Base" or "User"
     *     (since there are more appropriate services for removing users from groups: groupLeave and groupRemoveMembers).
     */
    delete: operations["groupRemoveChild"];
  };
  "/groups/{source_group_id}/permissions/{group_id}/{item_id}": {
    /**
     * Lets a manager of a group view permissions on an item for the group.
     * * The current user must be a manager (with `can_grant_group_access` permission) of `{source_group_id}` which should be an ancestor of the `{group_id}`.
     * * The current user must have `can_grant_view` > 'none' or `can_watch` = 'answer_with_grant' or `can_edit` = 'all_with_grant' on `{item_id}` on the item.
     */
    get: operations["permissionsView"];
    /**
     * Let a manager of a group give/withdraw permissions on an item to a group.
     * * The user giving the access must be a manager (with `can_grant_group_access` permission) of `{source_group_id}` which should be an ancestor of the `{group_id}`.
     * * The user giving the access must have `permissions_generated.can_grant_view` >= given `can_view` for the item.
     * * The group must already have access to one of the parents of the item or the item itself.
     */
    put: operations["updatePermissions"];
  };
  "/groups/is-code-valid": {
    /**
     * Checks if it is possible for the current user (or for a new user if the current user is temporary) to join a group with the given code. The service returns false:
     * * if there is no group with `code_expires_at` > NOW() (or NULL), `code` = `{code}`, and `type` != 'User'
     *   (`reason` = 'no_group');
     *
     * * if the group is a team and the user is already on a team that has attempts for same contest
     *   while the contest doesn't allow multiple attempts or that has active attempts for the same contest
     *   (`reason` = 'conflicting_team_participation'),
     *
     * * if the group membership is frozen (`reason` = 'frozen_membership');
     * * if there is already an active row in `groups_groups` with the found group as a parent
     *   and the user’s id as a child (`reason` = 'already_member');
     *
     * * if the group is a team and joining breaks entry conditions of at least one of the team's participations
     *   (i.e. any of `entry_min_admitted_members_ratio` or `entry_max_team_size` would not be satisfied)
     *   (`reason` = 'team_conditions_not_met').
     *
     * Otherwise, the service returns true.
     */
    get: operations["groupsCodeCheck"];
  };
  "/groups/possible-subgroups": {
    /** Searches for groups that can be added as subgroups, based on a substring of their name. Returns groups for which the user is a manager with `can_manage` = 'memberships_and_group', whose `name` has `{search}` as a substring. */
    get: operations["groupsPossibleSubgroupsSearch"];
  };
  "/groups/roots": {
    /** Returns groups which are ancestors of a joined groups or managed non-user groups and do not have parents, not considering "type='Base'" groups */
    get: operations["groupRootsView"];
  };
  "/groups/user-requests": {
    /**
     * Returns a list of group pending requests created by users with types listed in `{types}` (rows from the `group_pending_requests` table) with basic info on joining/leaving users for the group (if `{group_id}` is given) and its descendants (if `{group_id}` is given and `{include_descendant_groups}` is 1) or for all groups the current user can manage (`can_manage` >= 'memberships') (if `{group_id}` is not given).
     *
     * `first_name` and `last_name` are only shown for users whose personal info is visible to the current user. A user can see personal info of his own and of those members/candidates of his managed groups who have provided view access to their personal data.
     *
     * If `{group_id}` is given, the authenticated user should be a manager of `group_id` with `can_manage` >= 'memberships', otherwise the 'forbidden' error is returned. If the group is a user, the 'forbidden' error is returned as well.
     */
    get: operations["groupUserRequestsView"];
  };
  "/items": {
    /**
     * Creates an item with parameters from the input data with `items.default_language_tag` = `language_tag`. Also it
     *
     *   * inserts a row into `items_strings` with given `language_tag`, `title`, `image_url`, `subtitle`, `description`,
     *
     *   * gives full access to the item for the current user (creates a new `permissions_granted` row with: `item_id` = `items.id`,
     *     `group_id` = `group_id` of the current user, `source_group_id` = `users.group_id` of the current user, `origin` = 'self',
     *     `is_owner` = 1).
     *
     *   * adds new relations for the parent and (optionally) children items into `items_items` and propagates `permissions_generated`.
     *     (The only allowed parent-child relations are skills-*, chapter-task, chapter-course, chapter-chapter.
     *     Otherwise the "bad request" error is returned.)
     *
     *   * (if `requires_explicit_entry` is true) creates a participants group, links `participants_group_id` to it,
     *     and gives this group 'can_view:content' permission on the new item.
     *
     * The user should have
     *
     *   * `can_view` >= 'content' and `can_edit` >= 'children' on the `parent.item_id`,
     *   * `can_view` != 'none' on the `children` items (if any),
     *
     * otherwise the "bad request" response is returned.
     *
     * The current user should not be temporary, otherwise the "forbidden" error response is returned.
     *
     * At least one of `parent` and `as_root_of_group_id` should be given, otherwise the "bad request" error response is returned.
     */
    post: operations["itemCreate"];
  };
  "/items/{ancestor_item_id}/log": {
    /**
     * Returns rows from `answers` and started/validated `results` with additional info on users and items for the participant or the `{watched_group_id}` group (only one of `{as_team_id}` and `{watched_group_id}` can be given).
     *
     * If possible, items titles are shown in the authenticated user's default language. Otherwise, the item's default language is used.
     *
     * `first_name` and `last_name` of users are only visible to the users themselves and to managers of those users' groups to which they provided view access to personal data.
     *
     * If `{watched_group_id}` is given, all rows of the result are related to descendant groups of `{watched_group_id}` and items that are descendants of `{ancestor_item_id}` (+ `{ancestor_item_id}` itself) and visible to the current user (at least 'info' access with `can_watch` >= 'result').
     *
     * If `{watched_group_id}` is not given, all rows of the result are related to the participant group (the current user or `{as_team_id}`) and items that are descendants of `{ancestor_item_id}` (+ `{ancestor_item_id}` itself) and visible to the current user (at least 'info' access).
     */
    get: operations["itemActivityLogForItem"];
  };
  "/items/{dependent_item_id}/prerequisites/{prerequisite_item_id}": {
    /**
     * Creates an item dependency with parameters from the input data without any effect to access rights.
     * The user should have
     *
     *   * `can_view` >= 'info' on the `{prerequisite_item_id}` item,
     *   * `can_edit` >= 'all' on the `{dependent_item_id}` item,
     *   * if `grant_content_view` = true, the user should also have `can_grant_view` >= 'content'
     *     on the `{dependent_item_id}` item,
     *
     * otherwise the "forbidden" response is returned.
     */
    post: operations["itemDependencyCreate"];
    /**
     * Deletes the rule without any effect to access rights.
     *
     * * The current-user must have `can_edit` = 'all' on the `{dependent_item_id}`, otherwise the 'forbidden' error is returned.
     */
    delete: operations["itemDependencyDelete"];
  };
  "/items/{dependent_item_id}/prerequisites/{prerequisite_item_id}/apply": {
    /**
     * Applies the rule, i.e. grants the content access, for all existing participants which meet the condition defined by this dependency. The action doesn't affect access rights of those who doesn't meet the condition anymore.
     *
     * * The item dependency between `{dependent_item_id}` and `{prerequisite_item_id}` must exist with `grant_content_view` = 1, otherwise the 'not found' error is returned.
     * * The current-user must have `can_edit` = 'all' and `can_grant_view` >= 'content' on the `{dependent_item_id}`, otherwise the 'forbidden' error is returned.
     */
    post: operations["itemDependencyApply"];
  };
  "/items/{ids}/attempts": {
    /**
     * Creates a new attempt for the given item with `creator_id` equal to `group_id` of the current user and make it active for the user. If `as_team_id` is given, the created attempt is linked to the `as_team_id` group instead of the user's self group.
     *
     * Restrictions:
     *
     *   * if `as_team_id` is given, it should be a user's parent team group,
     *   * the first item in `{ids}` should be a root activity/skill (groups.root_activity_id/root_skill_id)
     *     of a group the participant is a descendant of,
     *   * `{ids}` should be an ordered list of parent-child items,
     *   * the group creating the attempt should have at least 'content' access on each of the items in `{ids}`,
     *   * the participant should have a started, allowing submission, not ended result for each item but the last,
     *     with `{parent_attempt_id}` (or its parent attempt each time we reach a root of an attempt) as the attempt,
     *   * if `{ids}` consists of only one item, the `{parent_attempt_id}` should be zero,
     *   * the last item in `{ids}` should be either 'Task', 'Course', or 'Chapter',
     *
     * otherwise the 'forbidden' error is returned.
     *
     * If there is already an attempt for the (item, group) pair, `items.allows_multiple_attempts` should be true, otherwise the "unprocessable entity" error is returned.
     */
    post: operations["attemptCreate"];
  };
  "/items/{ids}/breadcrumbs": {
    /**
     * Returns brief item information for items listed in `ids` in the user's preferred language (if exist) or the items' default language.
     *
     * Restrictions:
     *   * the list of item IDs should be a valid path from a root item
     *    (`items.id`=`groups.root_activity_id|root_skill_id` for one of the participant's ancestor groups),
     *   * `as_team_id` (if given) should be the current user's team,
     *   * the participant should have at least 'content' access on each listed item except the last one through that path,
     *     and at least 'info' access on the last item,
     *   * all the results within the ancestry of `attempt_id`/`parent_attempt_id` on the items path
     *     (except for the last item if `parent_attempt_id` is given) should be started (`started_at` is not null),
     *
     *   otherwise the 'forbidden' error is returned.
     */
    get: operations["itemBreadcrumbsGet"];
  };
  "/items/{ids}/enter": {
    /**
     * Allows to enter an item requiring explicit entry as a user or as a team (if `as_team_id` is given).
     *
     * Restrictions:
     *   * the last item in `{ids}` should require explicit entry;
     *   * `as_team_id` (if given) should be the current user's team;
     *   * the first item in `{ids}` should be a root activity/skill (groups.root_activity_id/root_skill_id)
     *     of a group the participant is a descendant of;
     *   * `{ids}` should be an ordered list of parent-child items;
     *   * the group (the user or his team) should have at least 'content' access
     *     on each of the items in `{ids}` except the last one and at least 'info' access for the last one;
     *   * the group should have a started, allowing submission, not ended result for each item but the last,
     *     with `{parent_attempt_id}` (or its parent attempt each time we reach a root of an attempt) as the attempt;
     *   * if `{ids}` consists of only one item, the `{parent_attempt_id}` should be zero;
     *   * the group (the user or his team) must be qualified for the last item in `{ids}` (itemGetEntryState returns "ready").
     *
     * Otherwise, the "Forbidden" response is returned.
     */
    post: operations["itemEnter"];
  };
  "/items/{ids}/start-result": {
    /**
     * Creates a new started result for the given item and attempt or sets `started_at` of an existing result (if it hasn't been set). If `as_team_id` is given, the created result is linked to the `as_team_id` group instead of the user's self group.
     *
     * Restrictions:
     *
     *   * if `as_team_id` is given, it should be a user's parent team group,
     *   * the first item in `{ids}` should be a root activity/skill (groups.root_activity_id/root_skill_id) of a group
     *     the participant is a descendant of,
     *   * the last item in `{ids}` should not require explicit entry (`items.requires_explicit_entry` should be false),
     *   * `{ids}` should be an ordered list of parent-child items,
     *   * the group starting the result should have at least 'content' access on each of the items in `{ids}`,
     *   * the participant should have a started, allowing submission, not ended result for each item but the last,
     *     with `{attempt_id}` (or its parent attempt each time we reach a root of an attempt) as the attempt,
     *   * if `{ids}` consists of only one item, the `{attempt_id}` should be zero,
     *
     * otherwise the 'forbidden' error is returned.
     */
    post: operations["resultStart"];
  };
  "/items/{ids}/start-result-path": {
    /**
     * Creates new started results (or starts not started existing ones) for an item path if needed and returns the last attempt in the chain.
     * Of all possible chains of attempts the service chooses the one having missing/not-started results located closer to the end of the path, preferring chains having less missing/not-started results and having higher values of `attempt_id`. If there is no result for the first item, the service tries to create an attempt chain starting with the zero attempt. The chain of attempts cannot have missing results for items requiring explicit entry or require to start/create results within or below ended/not-allowing-submissions attempts.
     * If `as_team_id` is given, the created/updated results are linked to the `as_team_id` group instead of the user's self group.
     *
     * Restrictions:
     *
     *   * if `as_team_id` is given, it should be a user's parent team group,
     *   * the first item in `{ids}` should be a root activity/skill (groups.root_activity_id/root_skill_id) of a group
     *     the participant is a descendant of,
     *   * `{ids}` should be an ordered list of parent-child items,
     *   * the group starting results should have at least 'content' access on each of the items in `{ids}`,
     *
     * otherwise the 'forbidden' error is returned.
     */
    post: operations["resultStartPath"];
  };
  "/items/{item_id}": {
    /**
     * Returns data related to the specified item, and the current user's (or the team's given in `{as_team_id}`) permissions on it (from tables `items`, `items_string`, `permissions_generated`).
     *
     * * If the specified item is not visible by the current user (or the team given in `as_team_id`), the 'not found' response is returned.
     * * If `{language_tag}` is given, but there is no items_strings row for the `{item_id}` and `{language_tag}`, the 'not found' response is returned as well.
     * * If `as_team_id` is given, it should be a user's parent team group, otherwise the "forbidden" error is returned.
     * * If `{watched_group_id}` is given, the user should ba a manager of the group with the 'can_watch_members' permission, otherwise the "forbidden" error is returned. Permissions of the watched group are only shown if the current user can watch the item or grant permissions to both the watched group and the item.
     */
    get: operations["itemView"];
    /**
     * Changes the given item's properties using the input data.
     *
     * If the `children` array is given, the service removes relations between the item and its former children, inserts relations between the item and its new children into `items_items`, and propagates `permissions_generated`. (The only allowed parent-child relations are skills-*, chapter-task, chapter-course, chapter-chapter. Otherwise the "bad request" error is returned.)
     *
     * If `requires_explicit_entry` is being set to true and `participants_group_id` is NULL, the service creates a participants group, links `participants_group_id` to it, and gives this group 'can_view:content' permission on the new item.
     *
     * The user should have
     *
     *   * `can_view` >= 'content' on the item, otherwise the "forbidden" response is returned;
     *   * `can_edit` >= 'children' on the item to edit children or `can_edit` >= 'all' to edit the item's properties,
     *     otherwise the "forbidden" response is returned;
     *   * `can_view` != 'none' on the `children` items (if any), otherwise the "bad request"
     *     response is returned.
     */
    put: operations["itemUpdate"];
    /**
     * Removes an item and objects linked to it.
     *
     * The service deletes `answers`, `groups_contest_items`, `item_dependencies` (by `item_id` and `dependent_item_id`), `items_ancestors` (by `child_item_id`), `items_items` (by `child_item_id`), `items_strings`, `permissions_generated`, `permissions_granted`, `permissions_propagate`, `results` linked to the item.
     *
     * The authenticated user should be an owner of the `{item_id}`, otherwise the "forbidden" error is returned.
     * Also, the item must not have any children, otherwise the "unprocessable entity" error is returned.
     */
    delete: operations["itemDelete"];
  };
  "/items/{item_id}/answers": {
    /**
     * Return answers (i.e., saved answers, current answer and submissions) for a given item and user, or from a given attempt.
     * * One of `author_id` or `attempt_id` is required.
     * * The user should have at least 'content' access to the item.
     * * If `author_id` is given, the authenticated user should be the input `author_id` or a manager of a group containing the input `author_id`.
     * * If `attempt_id` is given, the authenticated user should be a member or a manager of the group attached to the attempt.
     *
     * Users' `first_name` and `last_name` are only shown for the authenticated user or if the user approved access to their personal info for some group managed by the authenticated user.
     */
    get: operations["answersList"];
  };
  "/items/{item_id}/attempts": {
    /**
     * Returns attempts of the current participant (the current user or `{as_team_id}` team) with their results for the given item within the parent attempt.
     *
     * `first_name` and `last_name` of attempt creators are only visible to attempt creators themselves and to managers of those attempt creators' groups to which they provided view access to personal data.
     *
     * Restrictions:
     *   * `{as_team_id}` (if given) should be the current user's team,
     *   * the participant should have at least 'content' access on the item,
     *   * if `{attempt_id}` is given, it should exist for the participant in order to determine `{parent_attempt_id}`
     *     (we assume that the 'zero attempt' always exists and it is its own parent attempt),
     *
     * otherwise the 'forbidden' error is returned.
     */
    get: operations["attemptsList"];
  };
  "/items/{item_id}/attempts/{attempt_id}": {
    /**
     * Modifies values of an attempt result's properties a participant is able to modify.
     *
     * Restrictions:
     *
     *   * `{as_team_id}` (if given) should be the current user's team,
     *   * the participant should have a `results` row for the `{item_id}`-`{attempt_id}` pair,
     *
     * otherwise the 'forbidden' error is returned.
     */
    put: operations["resultUpdate"];
  };
  "/items/{item_id}/attempts/{attempt_id}/answers": {
    /**
     * Creates a "saved" answer from a current snapshot.
     * * The authenticated user should have at least 'content' access to the `{item_id}`.
     * * `{as_team_id}` (if given) should be the user's team.
     * * There should be a row in the `results` table with `attempt_id` = `{attempt_id}`, `participant_id` = the user's group (or `{as_team_id}` if given), `item_id` = `{item_id}`.
     * If any of the preconditions fails, the 'forbidden' error is returned.
     */
    post: operations["answerCreate"];
  };
  "/items/{item_id}/attempts/{attempt_id}/answers/current": {
    /**
     * Update participant's current answer. Used for auto-saving while working on a task.
     * * The authenticated user should have at least 'content' access to the `{item_id}`.
     * * `{as_team_id}` (if given) should be the user's team.
     * * There should be a row in the `results` table with `attempt_id` = `{attempt_id}`, `participant_id` = the user's group (or `{as_team_id}` if given), `item_id` = `{item_id}`
     * If any of the preconditions fails, the 'forbidden' error is returned.
     */
    put: operations["currentAnswerUpdate"];
  };
  "/items/{item_id}/attempts/{attempt_id}/generate-task-token": {
    /**
     * Generate a task token with the refreshed attempt.
     *
     * * `latest_activity_at` of `results` is set to the current time.
     * * Then the service returns a task token with fresh data for the attempt for the given item.
     *
     * Restrictions:
     *
     *   * if `{as_team_id}` is given, it should be a team and the current user should be a member of this team,
     *   * the user (or `{as_team_id}`) should have at least 'content' access to the item,
     *   * the item should be either 'Task' or 'Course',
     *   * there should be a row in the `results` table with `participant_id` equal to the user's group (or `{as_team_id}`),
     *     `attempt_id` = `{attempt_id}`, `item_id` = `{item_id}`, `started_at` set,
     *   * the attempt with (`participant_id`, `{attempt_id}`) should have allows_submissions_until in the future,
     *
     * otherwise the 'forbidden' error is returned.
     */
    post: operations["itemTaskTokenGenerate"];
  };
  "/items/{item_id}/attempts/{attempt_id}/publish": {
    /**
     * Publishes score obtained for the item within the attempt to LTI (via the login module).
     *
     * Restrictions:
     *
     *   * if `as_team_id` is given, it should be a user's parent team group,
     *   * the current user should have at least 'content' access on each of the `{item_id}` item,
     *   * the current user should have non-empty `login_id`,
     *
     * otherwise the 'forbidden' error is returned.
     */
    post: operations["resultPublish"];
  };
  "/items/{item_id}/breadcrumbs-from-roots": {
    /**
     * Lists all paths from a root (`root_activity_id`|`root_skill_id` of groups the participant is descendant of) to the given item that the participant may have used to access this item, so path for which the participant has a started attempt (possibly ended/not-allowing-submissions) on every item.
     *
     * The participant is `participant_id` (if given) or the current user (otherwise).
     *
     * Paths can contain only items visible to the current user (`can_view`>='content' on every item on the path but the last one and `can_view`>='info' for the last one). The item info (`title` and `language_tag`) in the paths is in the current user's language, or the item's default language (if not available).
     *
     * Restrictions:
     *
     *   * if `participant_id` is given, it should be a descendant of a group the current user can manage with `can_watch_members`,
     *   * at least one path should exist,
     *
     * otherwise the 'forbidden' error is returned.
     */
    get: operations["itemBreadcrumbsFromRootsGet"];
  };
  "/items/{item_id}/children": {
    /**
     * Lists children of the specified item and the current user's (or the team's given in `as_team_id`) interactions with them (from tables `items`, `items_items`, `items_string`, `results`, `permissions_generated`) within the context of the given `{attempt_id}`. Only items visible to the current user (or to the `{as_team_id}` team) are shown. If `{show_invisible_items}` = 1, items invisible to the current user (or to the `{as_team_id}` team) are shown too, but with a limited set of fields. If `{watched_group_id}` is given, some additional info about the given group's results on the items is shown.
     *
     * * The current user (or the team given in `as_team_id`) should have at least 'content' permissions on the specified item and a started result for it, otherwise the 'forbidden' response is returned.
     * * If `as_team_id` is given, it should be a user's parent team group, otherwise the "forbidden" error is returned.
     * * If `{watched_group_id}` is given, the user should ba a manager of the group with the 'can_watch_members' permission, otherwise the "forbidden" error is returned.
     */
    get: operations["itemChildrenView"];
  };
  "/items/{item_id}/current-answer": {
    /**
     * Returns the latest auto-saved ('Current') answer for the given `{item_id}` and `{attempt_id}`.
     * * The user should have at least 'content' access rights to the `item_id` item.
     * * The user should be able to see answers related to his group's attempts so the user should be a member of the `answers.participant_id` team or `answers.participant_id` should be equal to the user's self group.
     * * `{as_team_id}` (if given) should be the user's team.
     *
     * If any of the preconditions fails, the 'forbidden' error is returned.
     */
    get: operations["currentAnswerGet"];
  };
  "/items/{item_id}/dependencies": {
    /**
     * Lists dependent items for the specified item and the current user's (or the team's given in `as_team_id`) interactions with them (from tables `items`, `item_dependencies`, `items_string`, `results`, `permissions_generated`). Only items visible to the current user (or to the `{as_team_id}` team) are shown. If `{watched_group_id}` is given, some additional info about the given group's results on the items is shown.
     *
     * * The current user (or the team given in `as_team_id`) should have at least 'info' permissions on the specified item, otherwise the 'forbidden' response is returned.
     * * If `as_team_id` is given, it should be a user's parent team group, otherwise the "forbidden" error is returned.
     * * If `{watched_group_id}` is given, the user should ba a manager of the group with the 'can_watch_members' permission, otherwise the "forbidden" error is returned.
     */
    get: operations["itemDependenciesView"];
  };
  "/items/{item_id}/entry-state": {
    /**
     * For the given item requiring explicit entry and the given participant (the current user or his team if `as_team_id` is set), returns the entry state, i.e. whether the participant can enter the item, and info on each team member.
     *
     * `first_name` and `last_name` of other members are only visible to managers of those members' groups to which they provided view access to personal data.
     *
     * The entry state is one of:
     *   * 'already_started' if the participant has an `attempts` row for the item
     *     (with `attempts.root_item_id` = `{item_id}`) allowing submissions;
     *
     *   * 'not_ready' if the team itself cannot enter the item
     *     while there are more members than `entry_max_team_size` or
     *     the team/user doesn't satisfy the item's entry condition which is computed
     *     in accordance with `items.entry_min_admitted_members_ratio` as follows:
     *
     *       * "None": no additional conditions (the team/user can enter the item);
     *
     *       * "One": the current time needs to be between
     *         `permissions_granted.can_enter_from` and `permissions_granted.can_enter_until`
     *         and between `items.entering_time_min` and `items.entering_time_max`
     *         for the item and one of the group ancestors of either the user (if participating alone)
     *         or at least one member of the team;
     *
     *       * "All": same but all members of the team;
     *
     *       * "Half": same but half of the members (ceil-rounded) of the team;
     *
     *   * 'not_ready' if the participant has an `attempts` row for the item (with `attempts.root_item_id` = `{item_id}`)
     *     while the item's `allows_multiple_attempts` is false;
     *
     *   * 'not_ready' if at least one of the team's members as a member of another team
     *     has an `attempts` row for the item (with `attempts.root_item_id` = `{item_id}`)
     *     while the item's `allows_multiple_attempts` is false or an active (not expired) attempt;
     *
     *   * 'not_ready' if the item's `items.entry_frozen_teams` = 1,
     *     but the team membership is not frozen (`groups.frozen_membership` = 0);
     *
     *   * 'ready' otherwise.
     *
     * Restrictions:
     *   * `item_id` should require explicit entry;
     *   * `as_team_id` (if given) should be one of the current user's teams;
     *   * `as_team_id` should be given if the item is team-only and should not be given if the item is user-only;
     *   * the authenticated user (or his team) should have at least 'info' access to the item.
     *
     * Otherwise, the "Forbidden" response is returned.
     */
    get: operations["itemGetEntryState"];
  };
  "/items/{item_id}/navigation": {
    /**
     * Returns data needed to display the navigation menu (for `item_id` and its children) within the context of the given `{attempt_id}`/`{child_attempt_id}` (one of those should be given). Only items visible to the current user (or to the `{as_team_id}` team) are shown. If `{watched_group_id}` is given, some additional info about the given group's results on the items is shown.
     *
     * If `{child_attempt_id}` is given, the context-defining attempt id of the input item is either the same `{child_attempt_id}` or the `parent_attempt_id` of the given `{child_attempt_id}` (depending on the `root_item_id` of the `{child_attempt_id}`).
     *
     * * If the specified `{item_id}` doesn't exist or is not visible to the current user (or to the `{as_team_id}` team),
     *   of if there is no started result of the user/`{as_team_id}` for the context attempt id and the item,
     *   the 'forbidden' response is returned.
     *
     *
     * * If `{as_team_id}` is given, it should be a user's parent team group,
     *   otherwise the "forbidden" error is returned.
     *
     *
     * * If `{watched_group_id}` is given, the user should ba a manager of the group with the 'can_watch_members' permission,
     *   otherwise the "forbidden" error is returned.
     */
    get: operations["itemNavigationView"];
  };
  "/items/{item_id}/official-sessions": {
    /**
     * Lists the groups having `type`='Session', `is_official_session`=true, `is_public`=true, `root_activity_id`=`{item_id}` along with their parent groups (public or managed by the current user or having the current user as a member).
     *
     * Restrictions:
     *   * the current user should have at least 'info' permission on the item,
     *
     * otherwise the 'forbidden' error is returned.
     */
    get: operations["officialSessionsList"];
  };
  "/items/{item_id}/parents": {
    /**
     * Lists parents of the specified item and the current user's (or the team's given in `as_team_id`) interactions with them (from tables `items`, `items_items`, `items_string`, `results`, `permissions_generated`) within the context of the given `{attempt_id}`. Only items visible to the current user (or to the `{as_team_id}` team) are shown. If `{watched_group_id}` is given, some additional info about the given group's results on the items is shown.
     *
     * * The current user (or the team given in `as_team_id`) should have at least 'info' permissions on the specified item, otherwise the 'forbidden' response is returned.
     * * If `as_team_id` is given, it should be a user's parent team group, otherwise the "forbidden" error is returned.
     * * If `{watched_group_id}` is given, the user should ba a manager of the group with the 'can_watch_members' permission, otherwise the "forbidden" error is returned.
     */
    get: operations["itemParentsView"];
  };
  "/items/{item_id}/participant-progress": {
    /**
     * Returns the current progress of a participant on a given item.
     *
     * For `{item_id}` and all its visible children, displays the results of the given participant (current user or `as_team_id` (if given) or `watched_group_id` (if given)). Only one of `as_team_id` and `watched_group_id` can be given. The results are sorted by `items_items.child_order`.
     *
     * If the participant is a user, only the result corresponding to his best score counts (across all his teams and his own results) disregarding whether or not the score was done in a team.
     *
     * Restrictions:
     * * The current user (or the team given in `as_team_id`) should have at least 'content' permissions on `{item_id}`,
     *   otherwise the 'forbidden' response is returned.
     *
     * * If `{as_team_id}` is given, it should be a user's parent team group,
     *   otherwise the "forbidden" error is returned.
     *
     * * If `{watched_group_id}` is given, the user should be a manager of the group with the 'can_watch_members' permission,
     *   otherwise the "forbidden" error is returned.
     *
     * * If `{watched_group_id}` is given, it should be a user group or a team,
     *   otherwise the "forbidden" error is returned.
     *
     * * If `{watched_group_id}` is given, the current user should have `can_watch` >= 'result' on the `{item_id}` item,
     *   otherwise the "forbidden" error is returned.
     */
    get: operations["groupParticipantProgress"];
  };
  "/items/{item_id}/path-from-root": {
    /**
     * Finds a path from any of root items to a given item.
     *
     * The path consists only of the items visible to the participant (`can_view`>='content' for all the items except for the last one and `can_view`>='info' for the last one). Of all possible paths the service chooses the one having missing/not-started results located closer to the end of the path, preferring paths having less missing/not-started results and having higher values of `attempt_id`. The chain of attempts of the path cannot have missing results for items requiring explicit entry or not started results within or below ended/not-allowing-submissions attempts.
     *
     * If `as_team_id` is given, the attempts/results of the path are linked to the `as_team_id` group instead of the user's self group.
     *
     * Restrictions:
     *
     *   * if `as_team_id` is given, it should be a user's parent team group,
     *   * at least one path should exist,
     *
     * otherwise the 'forbidden' error is returned.
     */
    get: operations["itemPathFromRootFind"];
  };
  "/items/{item_id}/prerequisites": {
    /**
     * Lists prerequisite items for the specified item and the current user's (or the team's given in `as_team_id`) interactions with them (from tables `items`, `item_dependencies`, `items_string`, `results`, `permissions_generated`). Only items visible to the current user (or to the `{as_team_id}` team) are shown. If `{watched_group_id}` is given, some additional info about the given group's results on the items is shown.
     *
     * * The current user (or the team given in `as_team_id`) should have at least 'info' permissions on the specified item, otherwise the 'forbidden' response is returned.
     * * If `as_team_id` is given, it should be a user's parent team group, otherwise the "forbidden" error is returned.
     * * If `{watched_group_id}` is given, the user should ba a manager of the group with the 'can_watch_members' permission, otherwise the "forbidden" error is returned.
     */
    get: operations["itemPrerequisitesView"];
  };
  "/items/{item_id}/strings/{language_tag}": {
    /**
     * Updates the corresponding `items_strings` row identified by `item_id` and `language_tag` if exists or creates a new one otherwise.
     *
     * If `language_tag` = 'default', uses the item’s default language.
     *
     * The user should have `can_view` >= 'content' and `can_edit` >= 'all' on the item, otherwise the "forbidden" response is returned.
     */
    put: operations["itemStringUpdate"];
  };
  "/items/ask-hint": {
    /**
     * Saves the hint request into `results` and generates a new task token.
     *
     * Restrictions:
     *
     *   * `task_token` should belong to the current user, otherwise the "bad request" response is returned.
     *   * The current user should have submission rights to the `task_token`'s item,
     *     otherwise the "forbidden" response is returned.
     *   * There should be a row in the `results` with `participant_id`, `attempt_id`, and `item_id` matching the tokens
     *     and `attempts.allows_submissions_until` should be equal to time in the future,
     *     otherwise the "not found" response is returned.
     */
    post: operations["itemGetHintToken"];
  };
  "/items/log": {
    /**
     * Returns rows from `answers` and started/validated `results` with additional info on users and items for the participant or the `{watched_group_id}` group (only one of `{as_team_id}` and `{watched_group_id}` can be given).
     *
     * If possible, items titles are shown in the authenticated user's default language. Otherwise, the item's default language is used.
     *
     * `first_name` and `last_name` of users are only visible to the users themselves and to managers of those users' groups to which they provided view access to personal data.
     *
     * If `{watched_group_id}` is given, all rows of the result are related to descendant groups of `{watched_group_id}` and items that are visible to the current user (at least 'info' access with `can_watch` >= 'result').
     *
     * If `{watched_group_id}` is not given, all rows of the result are related to the participant group (the current user or `{as_team_id}`) and items that are visible to the current user (at least 'info' access).
     */
    get: operations["itemActivityLogForAllItems"];
  };
  "/items/save-grade": {
    /**
     * Saves the grade returned by a grading app into the `gradings` table and updates the attempt results in the DB. When the `score` is big enough, the service unlocks locked dependent items (if any) and updates `bAccessSolutions` of the task token.
     *
     * Restrictions:
     *
     *   * `task_token`, `score_token`/`answer_token` should belong to the current user, otherwise the "bad request"
     *      response is returned;
     *   * `idItemLocal`, `itemUrl`, `idAttempt` of the `task_token` should match ones in the `score_token`/`answer_token`,
     *     otherwise the "bad request" response is returned;
     *   * the answer should exist and should have not been graded, otherwise the "forbidden" response is returned.
     */
    post: operations["saveGrade"];
  };
  "/items/search": {
    /** Searches for visible (`can_view` >= 'info') items, basing on a substring of their titles in the current user's (if exists, otherwise default) language. */
    get: operations["itemSearch"];
  };
  "/user-batches": {
    /**
     * Creates a batch of users:
     * * creates a new row in users_batches,
     * * creates new users in the login module,
     * * inserts the created users into the `users` table,
     * * adds the created users into groups specified as `subgroups[...].group_id` giving all the required approvals.
     *
     * Restrictions:
     * * The authenticated user (or one of his group ancestors) should be a manager of the group
     *   (directly, or of one of its ancestors) linked to the `group_prefix`
     *   with at least 'can_manage:memberships', otherwise the 'forbidden' response is returned.
     * * The 'subgroup.group_id'-s should be descendants of the group linked to the `group_prefix` or be the group itself,
     *   otherwise the 'forbidden' response is returned.
     * * The 'subgroup.group_id'-s should not be of type 'User', otherwise the 'forbidden' response is returned. * The `group_prefix.allow_new` should be true, otherwise the 'forbidden' response is returned. * 32^`postfix_length` should be greater than 2 * sum of `subgroups.count`
     *   (to prevent being unable to generate unique logins), otherwise the 'bad request' response is returned.
     * * Sum of `subgroups.count` + sum of sizes of existing batches under the same `group_prefix`
     *   should not be greater than `max_users` of the prefix, otherwise the 'bad request' response is returned.
     */
    post: operations["createUserBatch"];
  };
  "/user-batches/{group_prefix}/{custom_prefix}": {
    /**
     * Lets a group manager remove user batches and all users having "{group_prefix}_{custom_prefix}_" as login prefix.
     *
     *
     * If the preconditions are satisfied, the service
     *
     *   * requests the login module to delete the users with "{group_prefix}\_{custom_prefix}\_" as prefix
     *     (/platform_api/accounts_manager/delete with the `prefix` parameter);
     *
     *   * deletes all users with "{group_prefix}\_{custom_prefix}\_" as prefix
     *     (ignoring the membership locks on groups that the authenticated user manages (but not others!));
     *
     *   * deletes the user batch entry.
     *
     * As we do not lock the DB between the preconditions checking and the actual deletion
     * with the call to the login module in the middle, there is possibility of deleting users
     * that haven't been checked or haven't been removed from the login module.
     *
     * If the local user deletion fails because of DB failure, there might be inconsistency between the DB
     * and the login module which can be fixed by retrying the request with the same parameters.
     *
     * Preconditions:
     *
     * * The authenticated user should be a manager of the `group_prefix`'s group (or its ancestor)
     *   with `can_manage` >= 'memberships', otherwise the 'forbidden' error is returned.
     *
     * * If there are users with locked membership in groups the current user cannot manage,
     *   the 'unprocessable entity' error is returned.
     */
    delete: operations["userBatchRemove"];
  };
  "/user-batches/by-group/{group_id}": {
    /** Lists the batches of users whose prefix can be used in the given group (i.e., the `group_id` is a descendant of the prefix group). Only those user batches are shown for which the authenticated user (or one of his group ancestors) is a manager of the prefix group (or its ancestor) with at least 'can_manage:memberships'. */
    get: operations["userBatchesView"];
  };
  "/users/{user_id}": {
    /** Returns data from the `users` table for the given `{user_id}` (`first_name` and `last_name` are only shown for the authenticated user or if the user approved access to their personal info for some group managed by the authenticated user) along with some permissions if the current user is a manager. */
    get: operations["userViewByID"];
  };
  "/users/by-login/{login}": {
    /** Returns data from the `users` table for the given `{login}` (`first_name` and `last_name` are only shown for the authenticated user or if the user approved access to their personal info for some group managed by the authenticated user) along with some permissions if the current user is a manager. */
    get: operations["userViewByLogin"];
  };
}

export interface definitions {
  /** GroupGroupTransitionResult is an enum{cycle, invalid, success, unchanged} */
  GroupGroupTransitionResult: string;
  /** GroupManagersViewResponseRowThroughAncestorGroups contains permissions propagated from ancestor groups */
  GroupManagersViewResponseRowThroughAncestorGroups: {
    /** displayed only when include_managers_of_ancestor_groups=1, note that the group is an ancestor of itself */
    can_grant_group_access_through_ancestor_groups?: boolean;
    can_manage_through_ancestor_groups?:
      | "none"
      | "memberships"
      | "memberships_and_group";
    /** displayed only when include_managers_of_ancestor_groups=1, note that the group is an ancestor of itself */
    can_watch_members_through_ancestor_groups?: boolean;
  };
  /** GroupManagersViewResponseRowUser contains names of a manager */
  GroupManagersViewResponseRowUser: {
    /** Nullable; displayed only for users */
    first_name?: string;
    /** Nullable; displayed only for users */
    last_name?: string;
    /** Displayed only for users */
    login?: string;
  };
  /** GroupShortInfo contains group id & name */
  GroupShortInfo: {
    /** group's `id` */
    id: string;
    name: string;
  };
  /** ItemPermissions represents all the permissions that a group can have on an item */
  ItemPermissions: {
    can_edit: "none" | "children" | "all" | "all_with_grant";
    can_grant_view:
      | "none"
      | "enter"
      | "content"
      | "content_with_descendants"
      | "solution"
      | "solution_with_grant";
    can_view:
      | "none"
      | "info"
      | "content"
      | "content_with_descendants"
      | "solution";
    can_watch: "none" | "result" | "answer" | "answer_with_grant";
    is_owner: boolean;
  };
  /** ItemResult represents item result info */
  ItemResult: {
    attempt_allows_submissions_until: string;
    attempt_id: string;
    /** Nullable */
    ended_at: string;
    latest_activity_at: string;
    score_computed: number;
    /** Nullable */
    started_at: string;
    validated: boolean;
  };
  /** ItemString represents a title with a related language tag for an item */
  ItemString: {
    /** language_tag (from `items_strings`) to which the title is related */
    language_tag: string;
    /** [Nullable] title (from `items_strings`) in the user’s default language or (if not available) default language of the item */
    title: string;
  };
  /** ItemWithRequiredType represents common item fields plus the required type field */
  ItemWithRequiredType: {
    allows_multiple_attempts?: boolean;
    display_details_in_parent?: boolean;
    /**
     * Nullable
     *
     * MySQL time (max value is 838:59:59), cannot be set for skills
     */
    duration?: string;
    entering_time_max?: string;
    entering_time_min?: string;
    entry_frozen_teams?: boolean;
    entry_max_team_size?: number;
    entry_min_admitted_members_ratio?: "All" | "Half" | "One" | "None";
    entry_participant_type?: "User" | "Team";
    fixed_ranks?: boolean;
    full_screen?: "forceYes" | "forceNo" | "default";
    hints_allowed?: boolean;
    no_score?: boolean;
    prompt_to_join_group_by_code?: boolean;
    read_only?: boolean;
    /** should be true when the duration is not null, cannot be set for skill items */
    requires_explicit_entry?: boolean;
    show_user_infos?: boolean;
    /** Nullable */
    text_id?: string;
    title_bar_visible?: boolean;
    /** Can be equal to 'Skill' only if the parent's type is 'Skill' */
    type: "Chapter" | "Task" | "Course" | "Skill";
    /** Nullable */
    url?: string;
    uses_api?: boolean;
    validation_type?:
      | "None"
      | "All"
      | "AllButOne"
      | "Categories"
      | "One"
      | "Manual";
  };
  /** These fields are only displayed if the current user is a manager of the user. */
  ManagerPermissionsPart: { [key: string]: any };
  /** can convert itself to sql/driver.Value (implements Valuer interface) and marshal itself as JSON (implements json.Marshaler) */
  Time: string;
  /** UserPersonalInfo contains first_name and last_name */
  UserPersonalInfo: {
    /** Nullable */
    first_name?: string;
    /** Nullable */
    last_name?: string;
  };
  activitiesViewResponseRow: {
    activity: definitions["rootItem"];
    group_id: string;
    name: string;
    type:
      | "Class"
      | "Team"
      | "Club"
      | "Friends"
      | "Other"
      | "User"
      | "Session"
      | "Base"
      | "ContestParticipants";
  };
  answerData: {
    answer: string;
    state: string;
  };
  /** Created. Success response with answer_token */
  answerSubmitResponse: definitions["createdResponse"] & {
    data: {
      answer_token?: string;
    };
  };
  answersResponseAnswer: {
    created_at: string;
    /** `answers.id` */
    id: string;
    /** Nullable */
    score: number;
    type: "Submission" | "Saved" | "Current";
    user: definitions["answersResponseAnswerUser"];
  };
  answersResponseAnswerUser: {
    /** Nullable */
    first_name?: string;
    /** Nullable */
    last_name?: string;
    login: string;
  };
  attemptsListResponseRow: {
    allows_submissions_until: string;
    created_at: string;
    /** Nullable */
    ended_at: string;
    help_requested: boolean;
    id: string;
    latest_activity_at: string;
    score_computed: number;
    /** Nullable */
    started_at: string;
    user_creator?: {
      /** Nullable */
      first_name?: string;
      group_id: string;
      /** Nullable */
      last_name?: string;
      login: string;
    };
    validated: boolean;
  };
  breadcrumbElement: {
    id: string;
    language_tag: string;
    /** Nullable */
    title: string;
  };
  childItem: {
    /** only for visible items */
    allows_multiple_attempts?: boolean;
    /**
     * max among all attempts of the user (or of the team given in `{as_team_id}`)
     * (only for visible items)
     */
    best_score?: number;
    /** `items_items.category` */
    category:
      | "Undefined"
      | "Discovery"
      | "Application"
      | "Validation"
      | "Challenge";
    /** `items_items.content_view_propagation` */
    content_view_propagation: "none" | "as_info" | "as_content";
    /** only for visible items */
    default_language_tag?: string;
    /** only for visible items */
    display_details_in_parent?: boolean;
    /** Nullable, only for visible items */
    duration?: string;
    /** `items_items.edit_propagation` */
    edit_propagation: boolean;
    /** only for visible items */
    entry_participant_type?: "User" | "Team";
    /** `items_items.grant_view_propagation` */
    grant_view_propagation: boolean;
    /**
     * whether solving this item grants access to some items (visible or not)
     * (only for visible items)
     */
    grants_access_to_items?: boolean;
    id: string;
    /** only for visible items */
    no_score?: boolean;
    /** `items_items.order` */
    order: number;
    permissions: definitions["ItemPermissions"];
    /** only for visible items */
    requires_explicit_entry?: boolean;
    /** only for visible items */
    results?: definitions["ItemResult"][];
    /** `items_items.score_weight` */
    score_weight: number;
    string?: definitions["visibleChildItemString"];
    /** only for visible items */
    type?: "Chapter" | "Task" | "Course" | "Skill";
    /** `items_items.upper_view_levels_propagation` */
    upper_view_levels_propagation:
      | "use_content_view_propagation"
      | "as_content_with_descendants"
      | "as_is";
    /** only for visible items */
    validation_type?:
      | "None"
      | "All"
      | "AllButOne"
      | "Categories"
      | "One"
      | "Manual";
    /** `items_items.watch_propagation` */
    watch_propagation: boolean;
    watched_group?: definitions["itemWatchedGroupStat"];
  };
  /**
   * Computed permissions for the group
   * (respecting permissions of its ancestors)
   */
  computedPermissions: {
    can_edit: "none" | "children" | "all" | "all_with_grant";
    /** The next time the group can enter the item (>= NOW()) */
    can_enter_from: string;
    can_grant_view:
      | "none"
      | "enter"
      | "content"
      | "content_with_descendants"
      | "solution"
      | "solution_with_grant";
    can_make_session_official: boolean;
    can_view:
      | "none"
      | "info"
      | "content"
      | "content_with_descendants"
      | "solution";
    can_watch: "none" | "result" | "answer" | "answer_with_grant";
    is_owner: boolean;
  };
  contestAdminListRow: {
    allows_multiple_attempts: boolean;
    entry_participant_type: "User" | "Team";
    id: string;
    language_tag: string;
    parents: definitions["parentTitle"][];
    /** Nullable */
    title: string;
  };
  contestInfo: {
    additional_time: number;
    group_id: string;
    name: string;
    total_additional_time: number;
    type: string;
  };
  createGroupManagerRequest: {
    can_grant_group_access?: boolean;
    can_manage?: "none" | "memberships" | "memberships_and_group";
    can_watch_members?: boolean;
  };
  createGroupRequest: {
    name: string;
    type: "Class" | "Team" | "Club" | "Friends" | "Other" | "Session";
  };
  createUserBatchRequest: {
    custom_prefix: string;
    group_prefix: string;
    password_length: number;
    postfix_length: number;
    subgroups: definitions["createUserBatchRequestSubgroup"][];
  };
  createUserBatchRequestSubgroup: {
    count: number;
    group_id: string;
  };
  createUserBatchResultRow: {
    group_id: string;
    users: definitions["resultRowUser"][];
  };
  createdResponse: {
    /** "created" */
    message: "created";
    /** true */
    success: boolean;
  };
  descendantParent: {
    id: string;
    name: string;
  };
  /** Permissions granted directly to the group via `origin` = 'group_membership' and `source_group_id` = `{source_group_id}` */
  grantedPermissionsStruct: {
    can_edit: "none" | "children" | "all" | "all_with_grant";
    can_enter_from: string;
    can_enter_until: string;
    can_grant_view:
      | "none"
      | "enter"
      | "content"
      | "content_with_descendants"
      | "solution"
      | "solution_with_grant";
    can_make_session_official: boolean;
    can_view:
      | "none"
      | "info"
      | "content"
      | "content_with_descendants"
      | "solution";
    can_watch: "none" | "result" | "answer" | "answer_with_grant";
    is_owner: boolean;
  };
  grantedPermissionsViewResultPermissions: {
    can_edit: "none" | "children" | "all" | "all_with_grant";
    can_enter_from: string;
    can_enter_until: string;
    can_grant_view:
      | "none"
      | "enter"
      | "content"
      | "content_with_descendants"
      | "solution"
      | "solution_with_grant";
    can_make_session_official: boolean;
    can_view:
      | "none"
      | "info"
      | "content"
      | "content_with_descendants"
      | "solution";
    can_watch: "none" | "result" | "answer" | "answer_with_grant";
    is_owner: boolean;
  };
  grantedPermissionsViewResultRow: {
    group: definitions["grantedPermissionsViewResultRowGroup"];
    item: {
      id: string;
      language_tag: string;
      requires_explicit_entry: boolean;
      /** Nullable */
      title: string;
    };
    permissions: definitions["grantedPermissionsViewResultPermissions"];
    source_group: definitions["grantedPermissionsViewResultRowGroup"];
  };
  grantedPermissionsViewResultRowGroup: {
    id: string;
    name: string;
  };
  groupBreadcrumbsViewResponseRow: {
    id: string;
    name: string;
    type:
      | "Class"
      | "Team"
      | "Club"
      | "Friends"
      | "Other"
      | "User"
      | "Session"
      | "Base";
  };
  groupChildrenViewResponseRow: {
    /** returned only if the current user is a manager */
    current_user_can_grant_group_access?: boolean;
    /** returned only if the current user is a manager */
    current_user_can_manage?: "none" | "memberships" | "memberships_and_group";
    /** returned only if the current user is a manager */
    current_user_can_watch_members?: boolean;
    current_user_is_manager: boolean;
    grade: number;
    /** The sub-group's `groups.id` */
    id: string;
    is_open: boolean;
    is_public: boolean;
    name: string;
    type:
      | "Class"
      | "Team"
      | "Club"
      | "Friends"
      | "Other"
      | "User"
      | "Session"
      | "Base";
    /** The number of descendant users (returned only if the current user is a manager) */
    user_count?: number;
  };
  groupCodeCheckResponse: {
    group?: definitions["groupCodeCheckResponseGroup"];
    /** Only if invalid */
    reason?:
      | "no_group"
      | "frozen_membership"
      | "already_member"
      | "conflicting_team_participation"
      | "team_conditions_not_met";
    valid: boolean;
  };
  /** Only if valid */
  groupCodeCheckResponseGroup: {
    managers: {
      /** Nullable */
      first_name: string;
      id: string;
      /** Nullable */
      last_name: string;
      login: string;
    }[];
    name: string;
    /** Nullable */
    require_lock_membership_approval_until: string;
    require_personal_info_access_approval: "none" | "view" | "edit";
    require_watch_approval: boolean;
    /** Nullable */
    root_activity_id: string;
    /** Nullable */
    root_skill_id: string;
  };
  groupGetResponse: {
    /** list of ancestor (excluding the group itself) groups that the current user (or his ancestor groups) is manager of */
    ancestors_current_user_is_manager_of: definitions["GroupShortInfo"][];
    /** Only for joined teams */
    can_leave_team?:
      | "frozen_membership"
      | "would_break_entry_conditions"
      | "free_to_leave";
    /** Nullable; returned only if the current user is a manager */
    code?: string;
    /** Nullable; returned only if the current user is a manager */
    code_expires_at?: string;
    /** Nullable; returned only if the current user is a manager */
    code_lifetime?: number;
    /** Nullable */
    created_at: string;
    /** returned only if the current user is a manager */
    current_user_can_grant_group_access?: boolean;
    /** returned only if the current user is a manager */
    current_user_can_manage?: "none" | "memberships" | "memberships_and_group";
    /** returned only if the current user is a manager */
    current_user_can_watch_members?: boolean;
    /**
     * whether the user (or its ancestor) is a manager of this group,
     * or a manager of one of this group's ancestors (so is implicitly manager of this group) or,
     * a manager of one of this group's non-user descendants, or none of above
     */
    current_user_managership: "none" | "direct" | "ancestor" | "descendant";
    /** whether the user is a member of this group or one of its descendants */
    current_user_membership: "none" | "direct" | "descendant";
    /** list of descendant (excluding the group itself) non-user groups that the current user (or his ancestor groups) is manager of */
    descendants_current_user_is_manager_of: definitions["GroupShortInfo"][];
    /** list of descendant (excluding the group itself) groups that the current user is member of */
    descendants_current_user_is_member_of: definitions["GroupShortInfo"][];
    /** Nullable */
    description: string;
    grade: number;
    /** group's `id` */
    id: string;
    is_membership_locked: boolean;
    is_open: boolean;
    is_public: boolean;
    name: string;
    open_activity_when_joining: boolean;
    /** Nullable */
    root_activity_id: string;
    /** Nullable */
    root_skill_id: string;
    type: "Class" | "Team" | "Club" | "Friends" | "Other" | "Session" | "Base";
  };
  groupGroupProgressResponseTableCell: {
    /**
     * Average score of all "end-members".
     * The score of an "end-member" is the max of his `results.score` or 0 if no results.
     */
    average_score: number;
    /**
     * Average number of hints requested by each "end-member".
     * The number of hints requested of an "end-member" is the `results.hints_cached`
     * of the result with the best score
     * (if several with the same score, we use the first result chronologically on `score_obtained_at`).
     */
    avg_hints_requested: number;
    /**
     * Average number of submissions made by each "end-member".
     * The number of submissions made by an "end-member" is the `results.submissions`.
     * of the result with the best score
     * (if several with the same score, we use the first result chronologically on `score_obtained_at`).
     */
    avg_submissions: number;
    /**
     * Average time spent among all the "end-members" (in seconds). The time spent by an "end-member" is computed as:
     *
     * 1) if no results yet: 0
     *
     * 2) if one result validated: min(`validated_at`) - min(`started_at`)
     * (i.e., time between the first time it started one (any) result
     * and the time he first validated the task)
     *
     * 3) if no results validated: `now` - min(`started_at`)
     */
    avg_time_spent: number;
    /** The child’s `group_id` */
    group_id: string;
    item_id: string;
    /**
     * % (float [0,1]) of "end-members" who have validated the task.
     * An "end-member" has validated a task if one of his results has `results.validated` = 1.
     * No results for an "end-member" is considered as not validated.
     */
    validation_rate: number;
  };
  groupInfoForRootItem: {
    group_id: string;
    name: string;
    type:
      | "Class"
      | "Team"
      | "Club"
      | "Friends"
      | "Other"
      | "User"
      | "Session"
      | "Base"
      | "ContestParticipants";
  };
  groupManagersViewResponseRow: {
    can_grant_group_access: boolean;
    /** displayed only when include_managers_of_ancestor_groups=1, note that the group is an ancestor of itself */
    can_grant_group_access_through_ancestor_groups?: boolean;
    can_manage: "none" | "memberships" | "memberships_and_group";
    can_manage_through_ancestor_groups?:
      | "none"
      | "memberships"
      | "memberships_and_group";
    can_watch_members: boolean;
    /** displayed only when include_managers_of_ancestor_groups=1, note that the group is an ancestor of itself */
    can_watch_members_through_ancestor_groups?: boolean;
    /** Nullable; displayed only for users */
    first_name?: string;
    /** `groups.id` */
    id: string;
    /** Nullable; displayed only for users */
    last_name?: string;
    /** Displayed only for users */
    login?: string;
    /** `groups.name` */
    name: string;
  };
  groupNavigationViewResponse: {
    children: definitions["groupNavigationViewResponseChild"][];
    id: string;
    name: string;
    type: "Class" | "Team" | "Club" | "Friends" | "Other" | "Session" | "Base";
  };
  groupNavigationViewResponseChild: {
    /**
     * whether the user (or its ancestor) is a manager of this group,
     * or a manager of one of this group's ancestors (so is implicitly manager of this group) or,
     * a manager of one of this group's non-user descendants, or none of above
     */
    current_user_managership: "none" | "direct" | "ancestor" | "descendant";
    /** whether the user is a member of this group or one of its descendants */
    current_user_membership: "none" | "direct" | "descendant";
    id: string;
    name: string;
    type: "Class" | "Team" | "Club" | "Friends" | "Other" | "Session" | "Base";
  };
  groupParticipantProgressResponse: {
    children: definitions["groupParticipantProgressResponseChild"][];
    item: definitions["groupParticipantProgressResponseCommon"];
  };
  groupParticipantProgressResponseChild: {
    current_user_permissions: definitions["ItemPermissions"];
    /**
     * Number of hints requested for the result with the best score (if multiple, take the first one, chronologically).
     * If there are no results, the number of hints is 0.
     */
    hints_requested: number;
    item_id: string;
    /** Nullable */
    latest_activity_at: string;
    no_score: boolean;
    /** The best score across all participant's or participant teams' results. If there are no results, the score is 0. */
    score: number;
    string: definitions["ItemString"];
    /**
     * Number of submissions for the result with the best score (if multiple, take the first one, chronologically).
     * If there are no results, the number of submissions is 0.
     */
    submissions: number;
    /**
     * Time spent by the participant (or his teams) (in seconds):
     *
     * 1) if no results yet: 0
     *
     * 2) if one result validated: min(`validated_at`) - min(`started_at`)
     * (i.e., time between the first time the participant (or one of his teams) started one (any) result
     * and the time he (or one of his teams) first validated the task)
     *
     * 3) if no results validated: `now` - min(`started_at`)
     */
    time_spent: number;
    type: "Chapter" | "Task" | "Course" | "Skill";
    /** Whether the participant or one of his teams has the item validated */
    validated: boolean;
  };
  groupParticipantProgressResponseCommon: {
    /**
     * Number of hints requested for the result with the best score (if multiple, take the first one, chronologically).
     * If there are no results, the number of hints is 0.
     */
    hints_requested: number;
    item_id: string;
    /** Nullable */
    latest_activity_at: string;
    /** The best score across all participant's or participant teams' results. If there are no results, the score is 0. */
    score: number;
    /**
     * Number of submissions for the result with the best score (if multiple, take the first one, chronologically).
     * If there are no results, the number of submissions is 0.
     */
    submissions: number;
    /**
     * Time spent by the participant (or his teams) (in seconds):
     *
     * 1) if no results yet: 0
     *
     * 2) if one result validated: min(`validated_at`) - min(`started_at`)
     * (i.e., time between the first time the participant (or one of his teams) started one (any) result
     * and the time he (or one of his teams) first validated the task)
     *
     * 3) if no results validated: `now` - min(`started_at`)
     */
    time_spent: number;
    /** Whether the participant or one of his teams has the item validated */
    validated: boolean;
  };
  groupRequestsViewResponseRow: {
    /** `group_membership_changes.action` */
    action:
      | "invitation_created"
      | "join_request_created"
      | "invitation_refused"
      | "join_request_refused";
    /** Nullable */
    at: string;
    /** Nullable */
    inviting_user: {
      /** Nullable */
      first_name: string;
      /** `users.group_id` */
      group_id: string;
      /** Nullable */
      last_name: string;
      login: string;
    };
    joining_user: {
      /** Nullable */
      first_name?: string;
      /** Nullable */
      grade: number;
      /** `users.group_id` */
      group_id: string;
      /** Nullable */
      last_name?: string;
      login: string;
    };
    /** `group_membership_changes.member_id` */
    member_id: string;
  };
  groupRootsViewResponseRow: {
    /**
     * whether the user (or its ancestor) is a manager of this group,
     * or a manager of one of this group's ancestors (so is implicitly manager of this group) or,
     * a manager of one of this group's non-user descendants, or none of above
     */
    current_user_managership: "none" | "direct" | "ancestor" | "descendant";
    /** whether the user is a member of this group or one of its descendants */
    current_user_membership: "none" | "direct" | "descendant";
    id: string;
    name: string;
    type: "Class" | "Team" | "Club" | "Friends" | "Other" | "User" | "Session";
  };
  groupTeamProgressResponseTableCell: {
    /** The team’s `group_id` */
    group_id: string;
    /**
     * Number of hints requested for the result with the best score (if multiple, take the first one, chronologically).
     * If there are no results, the number of hints is 0.
     */
    hints_requested: number;
    item_id: string;
    /** Nullable */
    latest_activity_at: string;
    /** Current score. If there are no results, the score is 0 */
    score: number;
    /**
     * Number of submissions for the result with the best score (if multiple, take the first one, chronologically).
     * If there are no results, the number of submissions is 0.
     */
    submissions: number;
    /**
     * Time spent by the team (in seconds):
     *
     * 1) if no results yet: 0
     *
     * 2) if one result validated: min(`validated_at`) - min(`started_at`)
     * (i.e., time between the first time it started one (any) attempt
     * and the time he first validated the task)
     *
     * 3) if no results validated: `now` - min(`started_at`)
     */
    time_spent: number;
    /** Whether the team has the item validated */
    validated: boolean;
  };
  /** Information of the group to be modified */
  groupUpdateInput: {
    /** Nullable */
    address_city?: string;
    /** Nullable */
    address_country?: string;
    /** Nullable */
    address_line1?: string;
    /** Nullable */
    address_line2?: string;
    /** Nullable */
    address_postcode?: string;
    /** Nullable */
    code_expires_at?: string;
    /**
     * Duration after the first use of the code when it will expire (in seconds)
     * Nullable
     */
    code_lifetime?: number;
    /** Nullable */
    description?: string;
    /** Cannot be set to true when max_participants is null */
    enforce_max_participants?: boolean;
    /** Nullable */
    expected_start?: string;
    /**
     * Can be changed only from false to true
     * (changing auto-rejects all pending join/leave requests and withdraws all pending invitations)
     */
    frozen_membership?: boolean;
    grade?: number;
    /**
     * Can be set only if root_activity_id is set and
     * the current user has the 'can_make_session_official' permission on the activity item
     */
    is_official_session?: boolean;
    is_open?: boolean;
    /** If changed from true to false, is automatically switches all requests to join this group from requestSent to requestRefused */
    is_public?: boolean;
    /** Nullable; cannot be set to null when enforce_max_participant is true */
    max_participants?: number;
    name?: string;
    open_activity_when_joining?: boolean;
    /** Nullable */
    organizer?: string;
    require_lock_membership_approval_until?: string;
    require_members_to_join_parent?: boolean;
    require_personal_info_access_approval?: "none" | "view" | "edit";
    require_watch_approval?: boolean;
    /** Nullable */
    root_activity_id?: number;
    /** Nullable */
    root_skill_id?: number;
  };
  groupUserProgressResponseTableCell: {
    /** The user’s self `group_id` */
    group_id: string;
    /**
     * Number of hints requested for the result with the best score (if multiple, take the first one, chronologically).
     * If there are no results, the number of hints is 0.
     */
    hints_requested: number;
    item_id: string;
    /** Nullable */
    latest_activity_at: string;
    /** The best score across all user's or user teams' results. If there are no results, the score is 0. */
    score: number;
    /**
     * Number of submissions for the result with the best score (if multiple, take the first one, chronologically).
     * If there are no results, the number of submissions is 0.
     */
    submissions: number;
    /**
     * Time spent by the user (or his teams) (in seconds):
     *
     * 1) if no results yet: 0
     *
     * 2) if one result validated: min(`validated_at`) - min(`started_at`)
     * (i.e., time between the first time the user (or one of his teams) started one (any) result
     * and the time he (or one of his teams) first validated the task)
     *
     * 3) if no results validated: `now` - min(`started_at`)
     */
    time_spent: number;
    /** Whether the user or one of his teams has the item validated */
    validated: boolean;
  };
  groupUserRequestsViewResponseRow: {
    at: string;
    group: {
      id: string;
      name: string;
    };
    type: "join_request" | "leave_request";
    user: {
      /** Nullable */
      first_name?: string;
      /** Nullable */
      grade: number;
      /** `users.group_id` */
      group_id: string;
      /** Nullable */
      last_name?: string;
      login: string;
    };
  };
  groupsMembersViewResponseRow: {
    /** the latest `group_membership_changes.action` */
    action?:
      | "invitation_accepted"
      | "join_request_accepted"
      | "joined_by_code"
      | "added_directly";
    /** `groups.id` */
    id: string;
    member_since?: string;
    user: {
      /** Nullable */
      first_name?: string;
      /** Nullable */
      grade: number;
      /** `users.group_id` */
      group_id: string;
      /** Nullable */
      last_name?: string;
      login: string;
    };
  };
  groupsMembershipHistoryResponseRow: {
    /** `group_membership_changes.action` */
    action:
      | "invitation_created"
      | "join_request_created"
      | "invitation_accepted"
      | "join_request_accepted"
      | "invitation_refused"
      | "joined_by_code"
      | "join_request_refused"
      | "join_request_withdrawn"
      | "invitation_withdrawn"
      | "removed"
      | "left"
      | "expired";
    /** `group_membership_changes.at` */
    at: string;
    group: {
      /** `groups.id` */
      id: number;
      name: string;
      type: "Class" | "Team" | "Club" | "Friends" | "Other" | "Session";
    };
  };
  invitationsViewResponseRow: {
    /** `group_membership_changes.action` */
    action:
      | "invitation_created"
      | "join_request_created"
      | "join_request_refused";
    /** `groups_groups.type_changed_at` */
    at: string;
    group: {
      /** Nullable */
      description: string;
      /** `groups.id` */
      id: number;
      name: string;
      type: "Class" | "Team" | "Club" | "Friends" | "Other";
    };
    /** `group_membership_changes.group_id` */
    group_id: number;
    /** the user that invited (Nullable: only for invitations) */
    inviting_user: {
      /** Nullable */
      first_name: string;
      /** `users.group_id` */
      id: number;
      /** Nullable */
      last_name: string;
      login: string;
    };
  };
  itemActivityLogResponseRow: {
    activity_type:
      | "result_started"
      | "submission"
      | "result_validated"
      | "saved_answer"
      | "current_answer";
    /** `answers.id` */
    answer_id?: string;
    at: string;
    attempt_id: string;
    /** use this as `{from.asnwer_id}` for pagination */
    from_answer_id: string;
    item: {
      id: string;
      string: {
        /** Nullable */
        title: string;
      };
      type: "Chapter" | "Task" | "Course" | "Skill";
    };
    participant: {
      id: string;
      name: string;
      type: "Team" | "User";
    };
    score?: number;
    user?: {
      /** Nullable */
      first_name?: string;
      id: string;
      /** Nullable */
      last_name?: string;
      login: string;
    };
  };
  itemChild: {
    category?:
      | "Undefined"
      | "Discovery"
      | "Application"
      | "Validation"
      | "Challenge";
    /**
     * Can be set to 'as_info' if `can_grant_view` != 'none' or to 'as_content' if `can_grant_view` >= 'content'.
     * Defaults to 'as_info' (if `can_grant_view` != 'none') or 'none'.
     * It is always possible to set this field to the same or a lower value, `can_grant_view` doesn't matter in this case.
     */
    content_view_propagation?: "none" | "as_info" | "as_content";
    /**
     * Can be set to true if `can_edit` >= 'all_with_grant'.
     * Defaults to true  if `can_edit` >= 'all_with_grant', false otherwise.
     * It is always possible to set this field to the same or a lower value, `can_edit` doesn't matter in this case.
     */
    edit_propagation?: boolean;
    /**
     * Can be set to true if `can_grant_view` >= 'solution_with_grant'.
     * Defaults to true  if `can_grant_view` >= 'solution_with_grant', false otherwise.
     * It is always possible to set this field to the same or a lower value, `can_grant_view` doesn't matter in this case.
     */
    grant_view_propagation?: boolean;
    item_id: string;
    order: number;
    score_weight?: number;
    /**
     * Can be set to 'as_is' (if `can_grant_view` >= 'solution') or 'as_content_with_descendants'
     * (if `can_grant_view` >= 'content_with_descendants') or 'use_content_view_propagation'.
     * Defaults to 'as_is' (if `can_grant_view` >= 'solution') or 'as_content_with_descendants'
     * (if `can_grant_view` >= 'content_with_descendants') or 'use_content_view_propagation' (otherwise).
     * It is always possible to set this field to the same or a lower value, `can_grant_view` doesn't matter in this case.
     */
    upper_view_levels_propagation?:
      | "use_content_view_propagation"
      | "as_content_with_descendants"
      | "as_is";
    /**
     * Can be set to true if `can_watch` >= 'answer_with_grant'.
     * Defaults to true  if `can_watch` >= 'answer_with_grant', false otherwise.
     * It is always possible to set this field to the same or a lower value, `can_watch` doesn't matter in this case.
     */
    watch_propagation?: boolean;
  };
  /** NewItemRequest is the expected input for new created item */
  itemCreateRequest: {
    allows_multiple_attempts?: boolean;
    as_root_of_group_id?: string;
    children?: definitions["itemChild"][];
    /** Nullable */
    description?: string;
    display_details_in_parent?: boolean;
    /**
     * Nullable
     *
     * MySQL time (max value is 838:59:59), cannot be set for skills
     */
    duration?: string;
    entering_time_max?: string;
    entering_time_min?: string;
    entry_frozen_teams?: boolean;
    entry_max_team_size?: number;
    entry_min_admitted_members_ratio?: "All" | "Half" | "One" | "None";
    entry_participant_type?: "User" | "Team";
    fixed_ranks?: boolean;
    full_screen?: "forceYes" | "forceNo" | "default";
    hints_allowed?: boolean;
    /** Nullable */
    image_url?: string;
    /** `default_language_tag` of the item */
    language_tag: string;
    no_score?: boolean;
    parent?: definitions["itemParent"];
    prompt_to_join_group_by_code?: boolean;
    read_only?: boolean;
    /** should be true when the duration is not null, cannot be set for skill items */
    requires_explicit_entry?: boolean;
    show_user_infos?: boolean;
    /** Nullable */
    subtitle?: string;
    /** Nullable */
    text_id?: string;
    title: string;
    title_bar_visible?: boolean;
    /** Can be equal to 'Skill' only if the parent's type is 'Skill' */
    type: "Chapter" | "Task" | "Course" | "Skill";
    /** Nullable */
    url?: string;
    uses_api?: boolean;
    validation_type?:
      | "None"
      | "All"
      | "AllButOne"
      | "Categories"
      | "One"
      | "Manual";
  };
  itemDependencyCreateRequest: {
    grant_content_view: boolean;
    score?: number;
  };
  /** updateItemRequest is the expected input for item updating */
  itemEditRequest: {
    allows_multiple_attempts?: boolean;
    children?: definitions["itemChild"][];
    /**
     * new `default_language_tag` of the item can only be set to a language
     * for that an `items_strings` row exists
     */
    default_language_tag?: string;
    display_details_in_parent?: boolean;
    /**
     * Nullable
     *
     * MySQL time (max value is 838:59:59), cannot be set for skills
     */
    duration?: string;
    entering_time_max?: string;
    entering_time_min?: string;
    entry_frozen_teams?: boolean;
    entry_max_team_size?: number;
    entry_min_admitted_members_ratio?: "All" | "Half" | "One" | "None";
    entry_participant_type?: "User" | "Team";
    fixed_ranks?: boolean;
    full_screen?: "forceYes" | "forceNo" | "default";
    hints_allowed?: boolean;
    no_score?: boolean;
    prompt_to_join_group_by_code?: boolean;
    read_only?: boolean;
    /** should be true when the duration is not null, cannot be set for skill items */
    requires_explicit_entry?: boolean;
    show_user_infos?: boolean;
    /** Nullable */
    text_id?: string;
    title_bar_visible?: boolean;
    /** Nullable */
    url?: string;
    uses_api?: boolean;
    validation_type?:
      | "None"
      | "All"
      | "AllButOne"
      | "Categories"
      | "One"
      | "Manual";
  };
  itemGetEntryStateOtherMember: {
    /**
     * true if the user has an active attempt as a member of another team for this item or
     * when the user has an expired attempt for this item as a member of another team
     * while the item doesn't allow multiple attempts
     */
    attempts_restriction_violated?: boolean;
    /**
     * whether at least one member's ancestor group has now()
     * between `items.entering_time_min` (or `permissions_granted.can_enter_from`) and
     * `items.entering_time_max` (or `permissions_granted.can_enter_until`) range for this item
     */
    can_enter: boolean;
    /** Nullable */
    first_name?: string;
    group_id: string;
    /** Nullable */
    last_name?: string;
    login?: string;
  };
  itemGetEntryStateResponse: {
    /** whether the current team has frozen membership (`groups.frozen_membership` = 0) */
    current_team_is_frozen: boolean;
    /**
     * whether at least one user's ancestor group has NOW() between
     * `permissions_granted.can_enter_from` and `permissions_granted.can_enter_until`
     * and between `items.entering_time_min` and `items.entering_time_max` for this item
     */
    current_user_can_enter: boolean;
    entry_min_admitted_members_ratio: "All" | "Half" | "One" | "None";
    /** whether a team should have frozen membership for entering the item (`items.entry_frozen_teams` = 1) */
    frozen_teams_required: boolean;
    /** `items.entry_max_team_size` (for team-only items) */
    max_team_size?: number;
    other_members: definitions["itemGetEntryStateOtherMember"][];
    state: "ready" | "already_started" | "not_ready";
  };
  itemNavigationResponse: {
    attempt_id: string;
    /** Nullable */
    children: definitions["navigationItemChild"][];
    id: string;
    permissions: definitions["ItemPermissions"];
    string: definitions["ItemString"];
    type: "Chapter" | "Task" | "Course" | "Skill";
  };
  itemParent: {
    category?:
      | "Undefined"
      | "Discovery"
      | "Application"
      | "Validation"
      | "Challenge";
    content_view_propagation?: "none" | "as_info" | "as_content";
    edit_propagation?: boolean;
    grant_view_propagation?: boolean;
    item_id?: string;
    score_weight?: number;
    upper_view_levels_propagation?:
      | "use_content_view_propagation"
      | "as_content_with_descendants"
      | "as_is";
    watch_propagation?: boolean;
  };
  itemResponse: {
    allows_multiple_attempts: boolean;
    /** max among all attempts of the user (or of the team given in `{as_team_id}`) */
    best_score: number;
    default_language_tag: string;
    display_details_in_parent: boolean;
    /** Nullable */
    duration: string;
    entering_time_max: string;
    entering_time_min: string;
    entry_frozen_teams: boolean;
    entry_max_team_size: number;
    entry_min_admitted_members_ratio: "All" | "Half" | "One" | "None";
    entry_participant_type: "User" | "Team";
    full_screen: "forceYes" | "forceNo" | "default";
    /** only if not a chapter */
    hints_allowed?: boolean;
    id: string;
    no_score: boolean;
    permissions: definitions["ItemPermissions"];
    prompt_to_join_group_by_code: boolean;
    read_only: boolean;
    requires_explicit_entry: boolean;
    show_user_infos: boolean;
    string: definitions["itemStringRoot"];
    supported_language_tags: string[];
    /** Nullable */
    text_id: string;
    title_bar_visible: boolean;
    type: "Chapter" | "Task" | "Course" | "Skill";
    /** Nullable; only if not a chapter */
    url?: string;
    /** only if not a chapter */
    uses_api?: boolean;
    validation_type:
      | "None"
      | "All"
      | "AllButOne"
      | "Categories"
      | "One"
      | "Manual";
    watched_group?: definitions["itemResponseWatchedGroupItemInfo"];
  };
  /** only if watched_group_id is given */
  itemResponseWatchedGroupItemInfo: {
    /**
     * Average score of all "end-members" within the watched group
     * (or of the watched group itself if it is a user or a team).
     * The score of an "end-member" is the max of his `results.score` or 0 if no results.
     * The field is only shown when the current user has 'can_watch' > 'none' permission on the item.
     */
    average_score?: number;
    permissions?: definitions["ItemPermissions"];
  };
  itemSearchResponseRow: {
    id: string;
    permissions: definitions["ItemPermissions"];
    /** Title (in current user's language); Nullable */
    title: string;
    type: "Chapter" | "Task" | "Course" | "Skill";
  };
  /** Item-related strings (from `items_strings`) in the user's default language (preferred) or the item's language */
  itemStringRoot: {
    /** Nullable; only if `can_view` >= 'content' */
    description?: string;
    /** Nullable; only if the user has access to solutions */
    edu_comment?: string;
    /** Nullable */
    image_url: string;
    language_tag: string;
    /** Nullable; only if `can_view` >= 'content' */
    subtitle?: string;
    /** Nullable */
    title: string;
  };
  /** itemStringUpdateRequest is the expected input for item's strings updating */
  itemStringUpdateRequest: {
    /** Nullable */
    description?: string;
    /** Nullable */
    image_url?: string;
    /** Nullable */
    subtitle?: string;
    title?: string;
  };
  /** only if `{watched_group_id}` is given */
  itemWatchedGroupStat: {
    /**
     * [only if the current user can watch for this item]
     * whether all descendant participants have accomplished the item (validated = true)
     */
    all_validated?: boolean;
    /**
     * [only if the current user can watch for this item]
     * average of the max scores of every descendant participants of the input group
     * (= 0 if a participant has no result yet on the item)
     */
    avg_score?: number;
    /** group's view permission on this item */
    can_view:
      | "none"
      | "info"
      | "content"
      | "content_with_descendants"
      | "solution";
  };
  listItemString: {
    language_tag: string;
    /** Nullable; only if `can_view` >= 'content' */
    subtitle?: string;
    /** Nullable */
    title: string;
  };
  loginIDCheckData: {
    login_id_matched: boolean;
  };
  /** enum: [cycle, invalid, success, unchanged, not_found] */
  loginTransitionResult: string;
  managedGroupsGetResponseRow: {
    can_grant_group_access: boolean;
    can_manage: "none" | "memberships" | "memberships_and_group";
    can_watch_members: boolean;
    /** Nullable */
    description: string;
    /** group's `id` */
    id: string;
    name: string;
    type: "Class" | "Team" | "Club" | "Friends" | "Other" | "Session" | "Base";
  };
  membershipsViewResponseRow: {
    /** `group_membership_changes.action` of the latest change */
    action:
      | "invitation_accepted"
      | "join_request_accepted"
      | "joined_by_code"
      | "added_directly";
    /** Only for teams */
    can_leave_team?:
      | "frozen_membership"
      | "would_break_entry_conditions"
      | "free_to_leave";
    group: {
      /** Nullable */
      description: string;
      /** `groups.id` */
      id: string;
      name: string;
      type: "Class" | "Team" | "Club" | "Friends" | "Other" | "Base";
    };
    is_membership_locked: boolean;
    /** MAX(`group_membership_changes.at`); Nullable */
    member_since: string;
  };
  navigationItemChild: {
    /** max among all attempts of the user (or of the team given in `{as_team_id}`) */
    best_score: number;
    entry_participant_type: "User" | "Team";
    /**
     * whether the item has children visible to the user and, at the same time,
     * the user has can_view >= 'content' permission on the item
     */
    has_visible_children: boolean;
    id: string;
    no_score: boolean;
    permissions: definitions["ItemPermissions"];
    requires_explicit_entry: boolean;
    results: definitions["ItemResult"][];
    string: definitions["ItemString"];
    type: "Chapter" | "Task" | "Course" | "Skill";
    watched_group?: definitions["itemWatchedGroupStat"];
  };
  officialSessionsListResponseRow: {
    /** Nullable */
    address_city: string;
    /** Nullable */
    address_country: string;
    /** Nullable */
    address_line1: string;
    /** Nullable */
    address_line2: string;
    /** Nullable */
    address_postcode: string;
    current_user_is_manager: boolean;
    /** `True` when there is an active group->user relation in `groups_groups` */
    current_user_is_member: boolean;
    /** Nullable */
    description: string;
    /** Nullable */
    expected_start: string;
    group_id: string;
    is_public: boolean;
    name: string;
    open_activity_when_joining: boolean;
    /** Nullable */
    organizer: string;
    parents: definitions["officialSessionsListResponseRowParent"][];
    /** Nullable */
    require_lock_membership_approval_until: string;
    require_members_to_join_parent: boolean;
    require_personal_info_access_approval: "none" | "view" | "edit";
    require_watch_approval: boolean;
  };
  officialSessionsListResponseRowParent: {
    current_user_is_manager: boolean;
    /** `True` when there is an active group->user relation in `groups_groups` */
    current_user_is_member: boolean;
    id: string;
    is_public: boolean;
    name: string;
  };
  parentItem: {
    allows_multiple_attempts: boolean;
    /** max among all attempts of the user (or of the team given in `{as_team_id}`) */
    best_score: number;
    /** `items_items.category` */
    category:
      | "Undefined"
      | "Discovery"
      | "Application"
      | "Validation"
      | "Challenge";
    default_language_tag: string;
    display_details_in_parent: boolean;
    /** Nullable */
    duration: string;
    entry_participant_type: "User" | "Team";
    id: string;
    no_score: boolean;
    /** `items_items.order` */
    order: number;
    permissions: definitions["ItemPermissions"];
    requires_explicit_entry: boolean;
    result: definitions["ItemResult"];
    string: definitions["listItemString"];
    type: "Chapter" | "Task" | "Course" | "Skill";
    validation_type:
      | "None"
      | "All"
      | "AllButOne"
      | "Categories"
      | "One"
      | "Manual";
    watched_group?: definitions["itemWatchedGroupStat"];
  };
  parentTitle: {
    language_tag: string;
    /** Nullable */
    title: string;
  };
  /**
   * Permissions granted to the group or its ancestors
   * via `origin` = 'group_membership' excluding the row from `granted`
   */
  permissionsGrantedViaGroupMembership: {
    can_edit: "none" | "children" | "all" | "all_with_grant";
    /** The next time the group can enter the item (>= NOW()) */
    can_enter_from: string;
    can_grant_view:
      | "none"
      | "enter"
      | "content"
      | "content_with_descendants"
      | "solution"
      | "solution_with_grant";
    can_make_session_official: boolean;
    can_view:
      | "none"
      | "info"
      | "content"
      | "content_with_descendants"
      | "solution";
    can_watch: "none" | "result" | "answer" | "answer_with_grant";
    is_owner: boolean;
  };
  /**
   * Permissions granted to the group or its ancestors
   * via `origin` = 'item_unlocking'
   */
  permissionsGrantedViaItemUnlocking: {
    can_edit: "none" | "children" | "all" | "all_with_grant";
    /** The next time the group can enter the item (>= NOW()) */
    can_enter_from: string;
    can_grant_view:
      | "none"
      | "enter"
      | "content"
      | "content_with_descendants"
      | "solution"
      | "solution_with_grant";
    can_make_session_official: boolean;
    can_view:
      | "none"
      | "info"
      | "content"
      | "content_with_descendants"
      | "solution";
    can_watch: "none" | "result" | "answer" | "answer_with_grant";
    is_owner: boolean;
  };
  /**
   * Permissions granted to the group or its ancestors
   * via `origin` = 'other'
   */
  permissionsGrantedViaOther: {
    can_edit: "none" | "children" | "all" | "all_with_grant";
    /** The next time the group can enter the item (>= NOW()) */
    can_enter_from: string;
    can_grant_view:
      | "none"
      | "enter"
      | "content"
      | "content_with_descendants"
      | "solution"
      | "solution_with_grant";
    can_make_session_official: boolean;
    can_view:
      | "none"
      | "info"
      | "content"
      | "content_with_descendants"
      | "solution";
    can_watch: "none" | "result" | "answer" | "answer_with_grant";
    is_owner: boolean;
  };
  /**
   * Permissions granted to the group or its ancestors
   * via `origin` = 'self'
   */
  permissionsGrantedViaSelf: {
    can_edit: "none" | "children" | "all" | "all_with_grant";
    /** The next time the group can enter the item (>= NOW()) */
    can_enter_from: string;
    can_grant_view:
      | "none"
      | "enter"
      | "content"
      | "content_with_descendants"
      | "solution"
      | "solution_with_grant";
    can_make_session_official: boolean;
    can_view:
      | "none"
      | "info"
      | "content"
      | "content_with_descendants"
      | "solution";
    can_watch: "none" | "result" | "answer" | "answer_with_grant";
    is_owner: boolean;
  };
  permissionsViewResponse: {
    computed: definitions["computedPermissions"];
    granted: definitions["grantedPermissionsStruct"];
    granted_via_group_membership: definitions["permissionsGrantedViaGroupMembership"];
    granted_via_item_unlocking: definitions["permissionsGrantedViaItemUnlocking"];
    granted_via_other: definitions["permissionsGrantedViaOther"];
    granted_via_self: definitions["permissionsGrantedViaSelf"];
  };
  prerequisiteOrDependencyItem: {
    allows_multiple_attempts: boolean;
    /** max among all attempts of the user (or of the team given in `{as_team_id}`) */
    best_score: number;
    default_language_tag: string;
    /** item_dependencies.grant_content_view */
    dependency_grant_content_view: boolean;
    /** item_dependencies.score */
    dependency_required_score: number;
    display_details_in_parent: boolean;
    /** Nullable */
    duration: string;
    entry_participant_type: "User" | "Team";
    id: string;
    no_score: boolean;
    permissions: definitions["ItemPermissions"];
    requires_explicit_entry: boolean;
    string: definitions["listItemString"];
    type: "Chapter" | "Task" | "Course" | "Skill";
    validation_type:
      | "None"
      | "All"
      | "AllButOne"
      | "Categories"
      | "One"
      | "Manual";
    watched_group?: definitions["itemWatchedGroupStat"];
  };
  resultRowUser: {
    login: string;
    password: string;
    user_id: string;
  };
  /** resultUpdateRequest is the expected input for result updating */
  resultUpdateRequest: {
    /** Toggle a help request on/off */
    help_requested?: boolean;
  };
  rootItem: {
    /** max among all attempts of the user (or of the team given in `{as_team_id}`) */
    best_score: number;
    entry_participant_type: "User" | "Team";
    has_visible_children: boolean;
    id: string;
    no_score: boolean;
    permissions: definitions["ItemPermissions"];
    requires_explicit_entry: boolean;
    results: definitions["ItemResult"][];
    string: definitions["ItemString"];
    type: "Chapter" | "Task" | "Course" | "Skill";
  };
  skillsViewResponseRow: {
    group_id: string;
    name: string;
    skill: definitions["rootItem"];
    type:
      | "Class"
      | "Team"
      | "Club"
      | "Friends"
      | "Other"
      | "User"
      | "Session"
      | "Base"
      | "ContestParticipants";
  };
  submitRequestWrapper: {
    answer: string;
    task_token: string;
  };
  teamDescendant: {
    grade: number;
    /** The team's `groups.id` */
    id: string;
    /** Team's member users */
    members: definitions["teamDescendantMember"][];
    name: string;
    /** Team's parent groups among the input group's descendants */
    parents: definitions["descendantParent"][];
  };
  teamDescendantMember: {
    /** Nullable */
    first_name?: string;
    /** Nullable */
    grade: number;
    group_id: number;
    /** Nullable */
    last_name?: string;
    login: string;
  };
  /** Unprocessable Entity response with a list of missing approvals */
  unprocessableEntityWithMissingApprovalsData: {
    missing_approvals?: ("personal_info_view" | "lock_membership" | "watch")[];
  };
  /** Access rights to be set */
  updatePermissionsInput: {
    /**
     * The granted `can_view` should be >= 'content' and
     * the current user should have permissions_generated.can_edit_generated = 'all_with_grant'
     * in order to increase level of this permission. Only owners can increase it to 'all_with_grant'.
     */
    can_edit?: string;
    /**
     * The current user should have permissions_generated.can_grant_view_generated >= 'enter' in order to
     * decrease this field's value.
     */
    can_enter_from?: string;
    /**
     * The current user should have permissions_generated.can_grant_view_generated >= 'enter' in order to
     * increase this field's value.
     */
    can_enter_until?: string;
    /**
     * The granted `can_view` should be >= the new value
     * (or 'info' if the new value is 'enter', or 'solution' if the new value is 'solution_with_grant') and
     * the current user should have `permissions_generated.can_grant_view_generated` = 'solution_with_grant'
     * in order to increase level of this permission. Only owners can increase it to 'solution_with_grant'.
     */
    can_grant_view?: string;
    /**
     * The granted `can_view` should be >= 'info' and
     * the current user should be an owner in order to change this field to true.
     */
    can_make_session_official?: boolean;
    /**
     * The current user should have `permissions_generated.can_grant_view_generated` >= the new value (or 'info' if the new value is 'enter')
     * in order to increase level of this permission
     */
    can_view?: string;
    /**
     * The granted `can_view` should be >= 'content' and
     * the current user should have `permissions_generated.can_watch_generated` = 'answer_with_grant'
     * in order to increase level of this permission. Only owners can increase it to 'answer_with_grant'.
     */
    can_watch?: string;
    /** Can be changed to true only if the current user is an owner of the item */
    is_owner?: boolean;
  };
  userBatch: {
    /** Nullable */
    creator_id: string;
    custom_prefix: string;
    group_prefix: string;
    size: number;
  };
  userBatchPrefix: {
    group_id: string;
    group_prefix: string;
    max_users: number;
    /** total number of users in the batches already using this group_prefix */
    total_size: number;
  };
  userCreateTmpResponse: definitions["createdResponse"] & {
    data: {
      /** Only if the cookie is not enabled */
      access_token?: string;
      /**
       * Number of seconds until the token's expiration
       * (when received by the UI, must be converted to actual time)
       */
      expires_in: number;
    };
  };
  userData: {
    /** Nullable */
    address: string;
    basic_editor_mode: boolean;
    /** Nullable */
    birth_date: string;
    /** Nullable */
    cell_phone_number: string;
    /** Nullable */
    city: string;
    country_code: string;
    default_language: string;
    /** Nullable */
    email: string;
    email_verified: boolean;
    /** Nullable */
    first_name: string;
    /** Nullable */
    free_text: string;
    /** Nullable */
    grade: number;
    graduation_year: number;
    group_id: string;
    is_admin: boolean;
    /** Nullable */
    land_line_number: string;
    /** Nullable */
    lang_prog: string;
    /** Nullable */
    last_name: string;
    login: string;
    no_ranking: boolean;
    notify: "Never" | "Answers" | "Concerned";
    notify_news: boolean;
    photo_autoload: boolean;
    public_first_name: boolean;
    public_last_name: boolean;
    /** Nullable */
    registered_at: string;
    /** Nullable */
    sex: "Male" | "Female";
    spaces_for_tab: number;
    step_level_in_site: number;
    /** Nullable */
    student_id: string;
    temp_user: boolean;
    /** Nullable */
    time_zone: string;
    /** Nullable */
    web_site: string;
    /** Nullable */
    zip_code: string;
  };
  userDataUpdateRequest: {
    default_language?: string;
  };
  userDescendant: {
    /** The user's self `groups.id` */
    id: string;
    /** The user's self `groups.name` */
    name: string;
    /** User's parent groups among the input group's descendants */
    parents: definitions["descendantParent"][];
    user: definitions["userDescendantUser"];
  };
  userDescendantUser: {
    /** Nullable */
    first_name?: string;
    /** Nullable */
    grade: number;
    /** Nullable */
    last_name?: string;
    login: string;
  };
  userViewResponse: {
    /** list of ancestor (excluding the user himself) groups that the current user (or his ancestor groups) is manager of */
    ancestors_current_user_is_manager_of: definitions["GroupShortInfo"][];
    /** returned only if the current user is a manager */
    current_user_can_grant_user_access?: boolean;
    /** returned only if the current user is a manager */
    current_user_can_watch_user?: boolean;
    /** Nullable */
    first_name?: string;
    /** Nullable */
    free_text: string;
    group_id: string;
    is_current_user: boolean;
    /** Nullable */
    last_name?: string;
    login: string;
    temp_user: boolean;
    /** Nullable */
    web_site: string;
  };
  visibleChildItemFields: {
    /** only for visible items */
    allows_multiple_attempts?: boolean;
    /**
     * max among all attempts of the user (or of the team given in `{as_team_id}`)
     * (only for visible items)
     */
    best_score?: number;
    /** only for visible items */
    default_language_tag?: string;
    /** only for visible items */
    display_details_in_parent?: boolean;
    /** Nullable, only for visible items */
    duration?: string;
    /** only for visible items */
    entry_participant_type?: "User" | "Team";
    /**
     * whether solving this item grants access to some items (visible or not)
     * (only for visible items)
     */
    grants_access_to_items?: boolean;
    /** only for visible items */
    no_score?: boolean;
    /** only for visible items */
    requires_explicit_entry?: boolean;
    /** only for visible items */
    results?: definitions["ItemResult"][];
    string?: definitions["visibleChildItemString"];
    /** only for visible items */
    type?: "Chapter" | "Task" | "Course" | "Skill";
    /** only for visible items */
    validation_type?:
      | "None"
      | "All"
      | "AllButOne"
      | "Categories"
      | "One"
      | "Manual";
  };
  /** only for visible items */
  visibleChildItemString: {
    language_tag: string;
    /** Nullable; only if `can_view` >= 'content' */
    subtitle?: string;
    /** Nullable */
    title: string;
  };
}

export interface responses {
  /** BadRequest. There is an error in the input data which was provided (path or body) to this service. */
  badRequestResponse: {
    schema: {
      /** The error message, for developers, only to be used for debugging. */
      error_text?: string;
      /**
       * In case of input data validation error, this may contain a map with, as key, the field in error
       * and, as value, an array of strings describing errors in English.
       */
      errors?: { [key: string]: any };
      message: "Bad Request";
      /** false */
      success: boolean;
    };
  };
  /** Conflict. Wrong resource state is not allowing to perform the operation */
  conflictResponse: {
    schema: {
      /** The error message, for developers, only to be used for debugging. */
      error_text?: string;
      message: "Forbidden";
      /** false */
      success: boolean;
    };
  };
  /** Created. Success response with the per-login results */
  createdLoginRelationsResponse: {
    schema: {
      /** `login` -> `result` */
      data: { [key: string]: definitions["loginTransitionResult"] };
      /** "created" */
      message: "created";
      /** true */
      success: true;
    };
  };
  /** The request has succeeded. The `data.changed` shows if the object has been created. */
  createdOrUnchangedResponse: {
    schema: {
      data: {
        changed: boolean;
      };
      message: "created" | "unchanged";
      /** true */
      success: boolean;
    };
  };
  /** Created. Success response with the created object's id. */
  createdWithIDResponse: {
    schema: {
      data: {
        id: string;
      };
      message: "created";
      /** true */
      success: boolean;
    };
  };
  /** The request has succeeded. The `data.changed` shows if the object has been deleted. */
  deletedOrUnchangedResponse: {
    schema: {
      data: {
        changed: boolean;
      };
      message: "deleted" | "unchanged";
      /** true */
      success: boolean;
    };
  };
  /** The request has successfully deleted the object */
  deletedResponse: {
    schema: {
      /** "deleted" */
      message: "deleted";
      /** true */
      success: boolean;
    };
  };
  /**
   * Forbidden. One of the permission requirements (cfr service description) is not met.
   * (note that some permission error may end up in not-found or bad-request errors)
   */
  forbiddenResponse: {
    schema: {
      /** The error message, for developers, only to be used for debugging. */
      error_text?: string;
      message: "Forbidden";
      /** false */
      success: boolean;
    };
  };
  /**
   * Internal Error. An unexpected error has happened on the server (e.g., uncaught database error).
   * If the problem persists, it should be reported.
   */
  internalErrorResponse: {
    schema: {
      /** The error message, for developers, only to be used for debugging. */
      error_text?: string;
      message: "Internal Server Error";
      /** false */
      success: boolean;
    };
  };
  /** OK. Success response with the requested answer */
  itemAnswerGetResponse: {
    schema: {
      /** Nullable */
      answer: string;
      /**
       * Nullable
       * format:integer
       */
      attempt_id: string;
      author_id: string;
      created_at: string;
      /** Nullable */
      graded_at: string;
      id: string;
      item_id: string;
      /** Nullable */
      score: number;
      /** Nullable */
      state: string;
      type: "Submission" | "Saved" | "Current";
    };
  };
  /** Created. The group has successfully entered the contest. */
  itemEnterResponse: {
    schema: {
      data: {
        /** Nullable */
        duration: string;
        entered_at: string;
      };
      message: "created";
      /** true */
      success: boolean;
    };
  };
  /**
   * Not Found. The requested object (or its scope) is not found
   * (note that this error may be caused by insufficient access rights)
   */
  notFoundResponse: {
    schema: {
      /** The error message, for developers, only to be used for debugging. */
      error_text?: string;
      message: "Not Found";
      /** false */
      success: boolean;
    };
  };
  /** Success or failure */
  publishedOrFailedResponse: {
    schema: {
      message: "published" | "failed";
      success: boolean;
    };
  };
  /** Success */
  successResponse: {
    schema: {
      /** "success" */
      message: "success";
      /** true */
      success: boolean;
    };
  };
  /** Unauthorized. The authorization token has not been provided or is invalid. */
  unauthorizedResponse: {
    schema: {
      /** The error message, for developers, only to be used for debugging. */
      error_text?: string;
      message: "Unauthorized";
      /** false */
      success: boolean;
    };
  };
  /**
   * Unprocessable Entity. Returned by services performing groups relations transitions to indicate
   * that the transition is impossible.
   */
  unprocessableEntityResponse: {
    schema: {
      /** The error message, for developers, only to be used for debugging. */
      error_text?: string;
      message: "Unprocessable Entity";
      /** false */
      success: boolean;
    };
  };
  /**
   * Unprocessable Entity. Returned by services performing groups relations transitions to indicate
   * that the transition is impossible because of missing approvals.
   */
  unprocessableEntityResponseWithMissingApprovals: {
    schema: {
      data?: definitions["unprocessableEntityWithMissingApprovalsData"];
      /** The error message, for developers, only to be used for debugging. */
      error_text?: string;
      message: "Unprocessable Entity";
      /** false */
      success: boolean;
    };
  };
  /** OK. Success response with the per-group update statuses */
  updatedGroupRelationsResponse: {
    schema: {
      /** `group_id` -> `result` */
      data: { [key: string]: definitions["GroupGroupTransitionResult"] };
      /** "updated" */
      message: "updated";
      /** true */
      success: boolean;
    };
  };
  /** The request has succeeded. The `data.changed` shows if the object has been updated. */
  updatedOrUnchangedResponse: {
    schema: {
      data: {
        changed: boolean;
      };
      message: "updated" | "unchanged";
      /** true */
      success: boolean;
    };
  };
  /** The request has successfully updated the object */
  updatedResponse: {
    schema: {
      /** "updated" */
      message: "updated";
      /** true */
      success: boolean;
    };
  };
}

export interface operations {
  /**
   * Generate and return an answer token from user's answer and task token. It is used to bind an answer with task parameters so that the TaskGrader can check if they have not been altered.
   * * task_token.idUser should be the current user.
   * * The user should have submission rights on `task_token.idItemLocal`.
   * * The attempt should allow submission (`attempts.allows_submissions_until` should be a time in the future).
   * If any of the preconditions fails, the 'forbidden' error is returned.
   */
  itemGetAnswerToken: {
    parameters: {
      body: {
        "answer information": definitions["submitRequestWrapper"];
      };
    };
    responses: {
      /** Created. Success response with answer_token */
      201: {
        schema: definitions["answerSubmitResponse"];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Returns the answer identified by the given `{answer_id}`.
   * - If the user is a participant
   *   - (s)he should have at least 'content' access rights to the `answers.item_id` and
   *   - be a member of the `answers.participant_id` team or
   *     `answers.participant_id` should be equal to the user's self group.
   *
   * - If the user is an observer
   *   - (s)he should have `can_watch` >= 'answer' permission on the `answers.item_id` and
   *   - be a manager with `can_watch_members` of an ancestor of `answers.participant_id` group.
   *
   * If any of the preconditions fails, the 'forbidden' error is returned.
   */
  answerGet: {
    parameters: {
      path: {
        answer_id: number;
      };
    };
    responses: {
      200: responses["itemAnswerGetResponse"];
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Allows to end an attempt as a user or as a team (if `as_team_id` is given).
   *
   * Restrictions:
   *   * `as_team_id` (if given) should be the current user's team;
   *   * the `{attempt_id}` should not be zero (since implicit attempts cannot be ended);
   *   * an attempt with `participant_id` = `as_team_id` (or the current user) and `id` = `attempt_id`
   *     should exist and not be ended or expired;
   *
   * Otherwise, the "Forbidden" response is returned.
   */
  itemAttemptEnd: {
    parameters: {
      path: {
        /** `id` of an attempt to end */
        attempt_id: number;
      };
      query: {
        as_team_id?: number;
      };
    };
    responses: {
      200: responses["updatedResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /** Removes the current user’s session (all access and refresh tokens) */
  authLogout: {
    responses: {
      200: responses["successResponse"];
      401: responses["unauthorizedResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Creates a temporary user and generates an access token valid for 2 hours.
   *
   * If attributes of the old and the new 'access_token' cookies are different (or the token is returned in the JSON), the old cookie gets deleted (otherwise, just overwritten).
   * * The "Authorization" header must not be given.
   * * When `{use_cookie}`=1, at least one of `{cookie_secure}` and `{cookie_same_site}` must be true.
   */
  tempUserCreate: {
    parameters: {
      query: {
        default_language?: string;
        /** If 1, set a cookie instead of returning the OAuth2 code in the data */
        use_cookie?: 0 | 1;
        /** If 1, set the cookie with the `Secure` attribute */
        cookie_secure?: 0 | 1;
        /** If 1, set the cookie with the `SameSite`='Strict' attribute value and with `SameSite`='None' otherwise */
        cookie_same_site?: 0 | 1;
      };
    };
    responses: {
      /** Created. Success response with the new access token */
      201: {
        schema: definitions["userCreateTmpResponse"];
      };
      400: responses["badRequestResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * If the `{code}` is given and the "Authorization" header is not given, the service converts the given OAuth2 authorization code into tokens, creates or updates the authenticated user in the DB with the data returned by the login module, and saves new access & refresh tokens into the DB as well. If OAuth2 authentication has used the PKCE extension, the `{code_verifier}` should be provided so it can be sent together with the `{code}` to the authentication server.
   *
   * If the `{code}` is not given while the "Authorization" header or/and the "access_token" is given (when both are given, the "Authorization" header is used and the cookie gets deleted), the service refreshes the access token (locally for temporary users or via the login module for normal users) and saves it into the DB keeping only the input token and the new token. Since the login module responds with both access and refresh tokens, the service updates the user's refresh token in this case as well. If there is no refresh token for the user in the DB, the 'not found' error is returned.
   *
   * If attributes of the old and the new 'access_token' cookies are different (or the token is returned in the JSON), the old cookie gets deleted (otherwise, just overwritten).
   *
   * * The "Authorization" header is not allowed when the `{code}` is given.
   * * When `{use_cookie}`=1, at least one of `{cookie_secure}` and `{cookie_same_site}` must be true.
   */
  accessTokenCreate: {
    parameters: {
      query: {
        /** OAuth2 code (can also be given in form data) */
        code?: string;
        /** OAuth2 PKCE code verifier  (can also be given in form data) */
        code_verifier?: string;
        /** OAuth2 redirection URI */
        redirect_uri?: string;
        /** If 1, set a cookie instead of returning the OAuth2 code in the data */
        use_cookie?: 0 | 1;
        /** If 1, set the cookie with the `Secure` attribute */
        cookie_secure?: 0 | 1;
        /** If 1, set the cookie with the `SameSite`='Strict' attribute value and with `SameSite`='None' otherwise */
        cookie_same_site?: 0 | 1;
      };
      body: {
        /** The optional parameters can be given in the body as well */
        parameters?: {
          /** OAuth2 code */
          code?: string;
          /** OAuth2 PKCE code verifier */
          code_verifier?: string;
          /** If true, set the cookie with the `SameSite`='Strict' attribute value and with `SameSite`='None' otherwise */
          cookie_same_site?: boolean;
          /** If true, set the cookie with the `Secure` attribute */
          cookie_secure?: boolean;
          /** OAuth2 redirection URI */
          redirect_uri?: string;
          /** If true, set a cookie instead of returning the OAuth2 code in the data */
          use_cookie?: boolean;
        };
      };
    };
    responses: {
      /** Created. Success response with the new access token */
      201: {
        schema: definitions["userCreateTmpResponse"];
      };
      400: responses["badRequestResponse"];
      404: responses["notFoundResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * For the input group and item, sets the `groups_contest_items.additional_time` to the `time` value. If there is no `groups_contest_items` for the given `group_id`, `item_id` and the `seconds` != 0, creates it (with default values in other columns). If no `groups_contest_items` and `seconds` == 0, succeed without doing any change.
   *
   * `groups_groups.expires_at` & `attempts.allows_submissions_until` (for the latest attempt) of affected `items.participants_group_id` members is set to `results.started_at` + `items.duration` + total additional time.
   *
   * Restrictions:
   *   * `item_id` should be a timed contest;
   *   * the authenticated user should have `can_view` >= 'content' on the input item;
   *   * the authenticated user should have `can_grant_view` >= 'enter' on the input item;
   *   * the authenticated user should have `can_watch` >= 'result' on the input item;
   *   * the authenticated user should be a manager of the `group_id`
   *     with `can_grant_group_access` and `can_watch_members` permissions;
   *   * if the contest is team-only (`items.entry_participant_type` = 'Team'), then the group should not be a user.
   *
   * Otherwise, the "Forbidden" response is returned.
   */
  contestSetAdditionalTime: {
    parameters: {
      path: {
        /** `id` of a timed contest */
        item_id: number;
        group_id: number;
      };
      query: {
        /** additional time in seconds (can be negative) */
        seconds: number;
      };
    };
    responses: {
      200: responses["updatedResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * For all descendant
   *
   *   * teams if `items.entry_participant_type` = 'Team'
   *   * end-users groups otherwise
   *
   * linked to the item via `attempts.root_item_id` and able to view (at least 'can_view:info') or enter (`can_enter_from` < `can_enter_until`) the item, the service returns their `group_id`, `name`, `type` and `additional_time` & `total_additional_time`.
   *
   * * `additional_time` defaults to 0 if no such `groups_contest_items`
   * * `total_additional_time` is the sum of additional times of this group on the item through all its
   *   `groups_ancestors` (even from different branches, but each ancestors counted only once), defaulting to 0
   *
   * Restrictions:
   *   * `item_id` should be a timed contest;
   *   * the authenticated user should have `can_view` >= 'content', `can_grant_view` >= 'enter',
   *     and `can_watch` >= 'result' on the input item;
   *   * the authenticated user should be a manager of the `group_id`
   *     with `can_grant_group_access` and `can_watch_members` permissions.
   */
  contestListMembersAdditionalTime: {
    parameters: {
      path: {
        /** `id` of a timed contest */
        item_id: number;
        group_id: number;
      };
      query: {
        /** Start the page from the group next to the group with `id`=`{from.id}` */
        "from.id"?: number;
        sort?: ("name" | "-name" | "id" | "-id")[];
        /** Display the first N groups */
        limit?: number;
      };
    };
    responses: {
      /** OK. Success response with contests info */
      200: {
        schema: definitions["contestInfo"][];
      };
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Return one group matching the name and satisfying:
   *
   *   * the group can view (at least 'can_view:info') or enter (`can_enter_from` < `can_enter_until`) the item;
   *   * the authenticated user is a manager of the group with `can_grant_group_access` and `can_watch_members` permissions;
   *   * the `groups.name` (matching `login` if a "User" group) is matching the input `name` parameter (case-insensitive)
   *
   * If there are several groups or users matching, returns the first one (by `id`).
   *
   * If the contest is a team-only contest (`items.entry_participant_type` = 'Team') and the name matches an end-user, returns his team instead of user’s group.
   *
   * Restrictions:
   *   * `item_id` should be a timed contest;
   *   * the authenticated user should have `can_view` >= 'content, `can_grant_view` >= 'enter', and `can_watch` >= 'result'
   *     on the input item.
   *
   * Otherwise, the "Forbidden" response is returned.
   *
   * __NOTE__: This service is only here for transition between the former interface and the new one.
   *       This way of searching only by `name`/`login` and getting one result is not really convenient,
   *       but matching the former UI. This service will have to be removed as soon as
   *       the new interface is used.
   */
  contestGetGroupByName: {
    parameters: {
      path: {
        /** `id` of a timed contest */
        item_id: number;
      };
      query: {
        name: string;
      };
    };
    responses: {
      /** OK. Success response with the `group_id`, `additional_time`, `total_additional_time` */
      200: {
        schema: definitions["contestInfo"];
      };
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Get the contests that the user has administration rights on.
   *
   * For all explicit-entry items that are timed contests and for that the user is a contest admin (has `can_view` >= 'content', `can_grant_view` >= 'enter', and `can_watch` >= 'result'), returns item info (`id`, `title`, `team_only_contest`, parents' `title`-s). Only parents visible to the user are listed.
   *
   * Each title is returned in the user's default language if exists, otherwise the item's default language is used.
   */
  contestAdminList: {
    parameters: {
      query: {
        /** Start the page from the contest next to the contest with `id`=`{from.id}` */
        "from.id"?: number;
        sort?: ("title" | "-title" | "id" | "-id")[];
        /** Display the first N contests */
        limit?: number;
      };
    };
    responses: {
      /** OK. Success response with contests info */
      200: {
        schema: definitions["contestAdminListRow"][];
      };
      401: responses["unauthorizedResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /** Returns the data from the `users` table. */
  userData: {
    responses: {
      /** OK. Success response with user's data */
      200: {
        schema: definitions["userData"];
      };
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /** Allows changing the user's default language */
  userDataUpdate: {
    parameters: {
      body: {
        data: definitions["userDataUpdateRequest"];
      };
    };
    responses: {
      200: responses["updatedResponse"];
      401: responses["unauthorizedResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Deletes all information stored in the platform related to the current user and calls the “UnlinkClient” service of the login module.
   * The data to be deleted:
   * 1. [`users_threads`, `filters`, `sessions`, `refresh_tokens`]
   *    having `user_id` = `users.group_id`;
   * 2. `answers` having `author_id` = `users.group_id`;
   * 3. [`permissions_granted`, `permissions_generated`, `attempts`]
   *    having `group_id` = `users.group_id`;
   *
   * 4. `groups_groups` having `parent_group_id` or `child_group_id` equal to `users.group_id`; 5. `group_pending_requests`/`group_membership_changes` having `group_id` or `member_id` equal
   *    to `users.group_id`;
   * 6. `groups_ancestors` having `ancestor_group_id` or `child_group_id` equal
   *    to `users.group_id`;
   * 7. [`groups_propagate`, `groups`] having `id` equal to `users.group_id`; 8. `users` having `group_id` = `users.group_id`.
   *
   * The deletion is rejected if the user is a member of at least one group with `now() < require_lock_membership_approval_until` and `groups_groups.lock_membership_approved` set.
   */
  currentUserDeletion: {
    responses: {
      200: responses["deletedResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Searches for groups that can be joined freely, based on a substring of their name. Returns groups with `is_public` = 1 and `type` != 'User', whose `name` has `search` as a substring, and for that the current user is not already a member and don’t have pending requests/invitations.
   *
   * Note: The current implementation may be very slow because it uses `LIKE` with a percentage wildcard at the beginning. This causes MySQL to explore every row having `is_public`=1. Moreover, actually it has to examine every row of the `groups` table since there is no index for the `is_public` column. But since there are not too many groups and the result rows count is limited, the search works almost well.
   */
  groupsJoinableSearch: {
    parameters: {
      query: {
        search: string;
        sort?: ("id" | "-id")[];
        /** Start the page from the group next to one with `groups.id`=`{from.id}` */
        "from.id"?: number;
        /** Display the first N groups */
        limit?: number;
      };
    };
    responses: {
      /** OK. Success response with an array of found groups */
      200: {
        schema: {
          /** Nullable */
          description: string;
          id: string;
          name: string;
          type:
            | "Class"
            | "Team"
            | "Club"
            | "Friends"
            | "Other"
            | "User"
            | "Base";
        }[];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /** Checks if a given `{login_id}` matches the one of the current user. */
  loginIDCheck: {
    parameters: {
      query: {
        login_id?: number;
      };
    };
    responses: {
      /** OK. Success response with the result */
      200: {
        schema: definitions["loginIDCheckData"];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Returns a downloadable JSON file with all the short version of the current user's data. The content returned is just the dump of raw entries of tables related to the user
   *
   *   * `current_user` (from `users`): all attributes;
   *   * `managed_groups`: `id` and `name` for every descendant of groups managed by the user;
   *   * `joined_groups`: `id` and `name` for every ancestor of user’s `group_id`;
   *   * `groups_groups`: where the user’s `group_id` is the `child_group_id`, all attributes + `groups.name`;
   *   * `group_managers`: where the user’s `group_id` is the `manager_id`, all attributes + `groups.name`;
   *
   * In case of unexpected error (e.g. a DB error), the response will be a malformed JSON like ```{"current_user":{"success":false,"message":"Internal Server Error","error_text":"Some error"}```
   */
  currentUserDataExport: {
    responses: {
      /** The returned data dump file */
      200: {
        schema: { [key: string]: any };
      };
      401: responses["unauthorizedResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Returns a downloadable JSON file with all the current user's data. The content returned is just the dump of raw entries of each table related to the user
   *
   *   * `current_user` (from `users`): all attributes;
   *   * `sessions`, `refresh_token`: all attributes, but secrets replaced with “***”;
   *   * `managed_groups`: `id` and `name` for every descendant of groups managed by the user;
   *   * `joined_groups`: `id` and `name` for every ancestor of user’s `group_id`;
   *   * `answers`: all attributes;
   *   * `attempts`: the user's or his teams' attempts, all attributes;
   *   * `results`: the user's or his teams' attempt results, all attributes;
   *   * `groups_groups`: where the user’s `group_id` is the `child_group_id`, all attributes + `groups.name`;
   *   * `group_managers`: where the user’s `group_id` is the `manager_id`, all attributes + `groups.name`;
   *   * `group_pending_requests`: where the user’s `group_id` is the `member_id`, all attributes + `groups.name`;
   *   * `group_membership_changes`: where the user’s `group_id` is the `member_id`, all attributes + `groups.name`.
   *
   * In case of unexpected error (e.g. a DB error), the response will be a malformed JSON like ```{"current_user":{"success":false,"message":"Internal Server Error","error_text":"Some error"}```
   */
  currentUserFullDataExport: {
    responses: {
      /** The returned data dump file */
      200: {
        schema: { [key: string]: any };
      };
      401: responses["unauthorizedResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /** Returns the list of invitations that the current user received and requests sent by him (`group_membership_changes.action` is “invitation_created” or “join_request_created” or “join_request_refused”) with `group_membership_changes.at` within `within_weeks` back from now (if `within_weeks` is present). */
  invitationsView: {
    parameters: {
      query: {
        within_weeks?: number;
        sort?: ("at" | "-at" | "group_id" | "-group_id")[];
        /** Start the page from the request/invitation next to one with `at` = `{from.at}` and `group_membership_changes.group_id` = `{from.group_id}` (`{from.group_id}` is required when `{from.at}` is present) */
        "from.at"?: string;
        /** Start the page from the request/invitation next to one with `at`=`{from.at}` and `group_id`=`{from.group_id}` (`{from.at}` is required when `{from.group_id}` is present) */
        "from.group_id"?: number;
        /** Display the first N requests/invitations */
        limit?: number;
      };
    };
    responses: {
      /** OK. Success response with an array of invitations/requests */
      200: {
        schema: definitions["invitationsViewResponseRow"][];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Lets the current user approve an invitation to join a group (idenfified by {group_id}). On success the service creates a new `groups_groups` row with `parent_group_id` = `group_id` and `child_group_id` = `user.group_id`, and a new `group_membership_changes` row with `action` = 'invitation_accepted' (the `at` field of both rows is set to current UTC time). The invitation gets removed from `group_pending_requests`. The service also refreshes the access rights.
   * * If the group is a team and the user is already on a team that has attempts for same contest while the contest doesn't allow multiple attempts or that has active attempts for the same contest, or if the group membership is frozen, the unprocessable entity error is returned.
   * * If the group is a team and joining breaks entry conditions of at least one of the team's participations (i.e. any of `entry_min_admitted_members_ratio` or `entry_max_team_size` would not be satisfied), the unprocessable entity error is returned.
   * * There should be a row in `group_pending_requests` with the `{group_id}` as a parent as `group_id` and the authenticated user’s `group_id` as `member_id` with `type`='invitation'. Otherwise the "not found" error is returned.
   * * If some of approvals required by the group are missing in `approvals`, the unprocessable entity error is returned with a list of missing approvals.
   * * If the group doesn't exist or is a user, or if the current user is temporary, the "forbidden" response is returned.
   */
  groupInvitationAccept: {
    parameters: {
      path: {
        group_id: number;
      };
      query: {
        approvals?: ("personal_info_view" | "lock_membership" | "watch")[];
      };
    };
    responses: {
      200: responses["updatedOrUnchangedResponse"];
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      422: responses["unprocessableEntityResponseWithMissingApprovals"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Lets the current user reject an invitation to join a group (identified by {group_id}). On success the service removes a `groups_pending_request` row with `group_id` = `{group_id}` and `member_id` = `user.group_id`, and adds a new `group_membership_changes` row with `action` = 'invitation_refused' and `at` = current UTC time.
   * * There should be a row in `group_pending_requests` with the `{group_id}` as `group_id` and the authenticated user’s `group_id` as `member_id` with `type`=`invitation_created`. Otherwise the unprocessable entity error is returned.
   */
  groupInvitationReject: {
    parameters: {
      path: {
        group_id: number;
      };
    };
    responses: {
      200: responses["updatedOrUnchangedResponse"];
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      422: responses["unprocessableEntityResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Lets the current user create a request to leave a group (idenfified by {group_id}).
   *
   * On success the service creates a new row in `group_pending_requests` with `group_id` = `{group_id}` `type` = 'leave_request' and `member_id` = user's `group_id` + a new row in `group_membership_changes` with `action` = `leave_request_created` and `at` equal to current UTC time.
   *
   * If there is already a row in `groups_groups` and a row in `group_pending_request` with `type` == 'leave_request', the "unchanged" (201) response is returned.
   *
   * The user should be a member of the `{group_id}` and the group's `require_lock_membership_approval_until` should be greater than NOW(), and `groups_groups.lock_membership_approved` should be set, and the group membership should not be frozen. Otherwise the "forbidden" error is returned.
   */
  groupLeaveRequestCreate: {
    parameters: {
      path: {
        group_id: number;
      };
    };
    responses: {
      201: responses["createdOrUnchangedResponse"];
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      422: responses["unprocessableEntityResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Lets the current user withdraw a request to leave a group (idenfified by {group_id}).
   *
   * On success the service removes a row  with `group_id` = `{group_id}`, `type` = 'leave_request' and `member_id` = user's `group_id` from the `group_pending_requests` table and creates a new row in `group_membership_changes` with `action` = `leave_request_withdrawn` and `at` equal to current UTC time.
   *
   * The user should be a member of the group and there should be a row with `type` = 'leave_request', `group_id` = `{parent_group_id}` and `member_id` = user's `group_id` in `group_pending_requests`, otherwise the "not found" error is returned.
   */
  groupLeaveRequestWithdraw: {
    parameters: {
      path: {
        group_id: number;
      };
    };
    responses: {
      200: responses["updatedResponse"];
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      404: responses["notFoundResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /** Returns the list of groups memberships of the current user. */
  membershipsView: {
    parameters: {
      query: {
        sort?: ("member_since" | "-member_since" | "id" | "-id")[];
        /** Start the page from the membership next to one with `groups.id`=`{from.id}` */
        "from.id"?: number;
        /** Display the first N memberships */
        limit?: number;
      };
    };
    responses: {
      /** OK. Success response with an array of groups memberships */
      200: {
        schema: definitions["membershipsViewResponseRow"][];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /** Returns the records from `group_membership_changes` having `at` >= `users.notifications_read_at` and any user-related type (`action` != "added_directly") with the corresponding `groups` for the current user. */
  groupsMembershipHistory: {
    parameters: {
      query: {
        sort?: ("at" | "-at" | "group_id" | "-group_id")[];
        /** Start the page from the invitation/request next to one with `at` = `{from.at}` and `group_membership_changes.group_id` = `{from.group_id}` (`{from.group_id}` is required when `{from.at}` is present) */
        "from.at"?: string;
        /** Start the page from the invitation/request next to one with `at`=`{from.at}` and `group_membership_changes.group_id`=`{from.group_id}` (`{from.at}` is required when `{from.group_id}` is present) */
        "from.group_id"?: number;
        /** Return the first N invitations/requests */
        limit?: number;
      };
    };
    responses: {
      /** OK. Success response with an array of invitations/requests */
      200: {
        schema: definitions["groupsMembershipHistoryResponseRow"][];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Lets a user to leave a group. On success the service removes a row with with `parent_group_id` = `group_id` and `child_group_id` = `user.group_id` from `groups_groups`, and adds a new `group_membership_changes` row with `action` = 'left' and `at` = current UTC time. It also refreshes the access rights.
   * * There should be a row in `groups_groups` with the `group_id` as a parent and the authenticated user’s `id` as a child. Otherwise the "not found" error is returned.
   * * The user cannot leave the group if `NOW()` < `groups.require_lock_membership_approval_until` and `groups_groups.lock_membership_approved` is set or if the group membership is frozen or if the group is a 'Base' group. Otherwise the "forbidden" error is returned.
   * * If the group is a team and leaving breaks entry conditions of at least one of the team's participations (i.e. any of `entry_min_admitted_members_ratio` or `entry_max_team_size` would not be satisfied), the unprocessable entity error is returned.
   */
  groupLeave: {
    parameters: {
      path: {
        group_id: number;
      };
    };
    responses: {
      200: responses["deletedOrUnchangedResponse"];
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      404: responses["notFoundResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * If `{watched_group_id}` is not given, the service returns the list of root activities of the groups the current user (or `{as_team_id}`) belongs to. Otherwise, the service returns the list of root activities (visible to the current user or `{as_team_id}`) of all ancestor groups of the watched group which are also ancestors or descendants of at least one group that the current user manages explicitly. Permissions returned for activities are related to the current user (or `{as_team_id}`). Only one of `{as_team_id}` and `{watched_group_id}` can be given.
   *
   * If `{as_team_id}` is given, it should be a user's parent team group, otherwise the "forbidden" error is returned.
   *
   * If `{watched_group_id}` is given, the user should ba a manager (implicitly) of the group with the 'can_watch_members' permission, otherwise the "forbidden" error is returned.
   */
  activitiesView: {
    parameters: {
      query: {
        as_team_id?: number;
        watched_group_id?: number;
      };
    };
    responses: {
      /** OK. Success response with an array of root activities */
      200: {
        schema: definitions["activitiesViewResponseRow"][];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Lets a user to join a group by a code. On success the service inserts a row into `groups_groups` with `parent_group_id` = `id` of the group found by the code and `child_group_id` = `group_id` of the user and another row into `group_membership_changes` with `group_id` = `id` of the group, `member_id` = `group_id` of the user, `action`=`joined_by_code`, and `at` = current UTC time. It also refreshes the access rights.
   * * If there is no group with `code_expires_at` > NOW() (or NULL), `code` = `{code}`, and `type` != 'User' or if the current user is temporary, the forbidden error is returned.
   * * If the group is a team and the user is already on a team that has attempts for same contest while the contest doesn't allow multiple attempts or that has active attempts for the same contest, or if the group membership is frozen, the unprocessable entity error is returned.
   * * If there is already a row in `groups_groups` with the found group as a parent and the authenticated user’s selfGroup’s id as a child, the unprocessable entity error is returned.
   * * If the group is a team and joining breaks entry conditions of at least one of the team's participations (i.e. any of `entry_min_admitted_members_ratio` or `entry_max_team_size` would not be satisfied), the unprocessable entity error is returned.
   * * If the group requires some approvals from the user and those are not given in `approval`, the unprocessable entity error is returned with a list of missing approvals.
   * * If `groups.enforce_max_participants` is true and the number of participants >= `groups.max_participants`, the conflict error is returned. (The number of participants is computed as the number of non-expired users or teams which are direct children of the group + invitations (join requests are not counted)).
   */
  groupsJoinByCode: {
    parameters: {
      query: {
        code: string;
        approvals?: ("personal_info_view" | "lock_membership" | "watch")[];
      };
    };
    responses: {
      /** Created. The request has successfully created the group relation. */
      201: {
        schema: definitions["createdResponse"];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      409: responses["conflictResponse"];
      422: responses["unprocessableEntityResponseWithMissingApprovals"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * If `{watched_group_id}` is not given, the service returns the list of root skills of the groups the current user (or `{as_team_id}`) belongs to. Otherwise, the service returns the list of root skills (visible to the current user or `{as_team_id}`) of all ancestor groups of the watched group which are also ancestors or descendants of at least one group that the current user manages explicitly. Permissions returned for skills are related to the current user (or `{as_team_id}`). Only one of `{as_team_id}` and `{watched_group_id}` can be given.
   *
   * If `{as_team_id}` is given, it should be a user's parent team group, otherwise the "forbidden" error is returned.
   *
   * If `{watched_group_id}` is given, the user should ba a manager (implicitly) of the group with the 'can_watch_members' permission, otherwise the "forbidden" error is returned.
   */
  skillsView: {
    parameters: {
      query: {
        as_team_id?: number;
        watched_group_id?: number;
      };
    };
    responses: {
      /** OK. Success response with an array of root skills */
      200: {
        schema: definitions["skillsViewResponseRow"][];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Lets the current user create a request to join a group (idenfified by {group_id}). There are two possible cases:
   * #### The user is not a manager of the group
   *
   *   On success the service creates a new row in `group_pending_requests` with
   *   `group_id` = `{group_id}`, `member_id` = user's self group id, `type` = 'join_request',
   *   given `approvals` and `at` equal to current UTC time,
   *   and a new row in `group_membership_changes` for the same pair of groups
   *   with `action` = 'join_request_created' and `at` equal to current UTC time.
   *
   *   * `groups.is_public` should be 1, otherwise the 'forbidden' response is returned.
   *
   *   * If there is already a row in `group_pending_requests` with
   *     `type` != 'join_request' or a row in `groups_groups` for the same group-user pair,
   *     the unprocessable entity error is returned.
   *
   *   * If there is already a row in `group_pending_requests` with `type` = 'join_request',
   *     the "unchanged" (201) response is returned.
   *
   * #### The user is a manager of the group with `can_manage` >= 'memberships'
   *
   *   On success the service creates a new row in `groups_groups` with `parent_group_id` = `group_id`,
   *   given `approvals` and `child_group_id` = user's self group id + a new row in `group_membership_changes`
   *   for the same group pair with `action` = `join_request_accepted` and `at` equal to current UTC time.
   *   A pending request/invitation gets removed from `group_pending_requests`.
   *
   *   * If there is already a row in `groups_groups` or a row in `group_pending_request` with
   *     `type` != 'invitation'/'join_request', the unprocessable entity error is returned.
   *
   *   On success, the service propagates group ancestors in this case.
   *
   *
   * In both cases, if some approvals required by the group are missing in `approvals`, the unprocessable entity error with a list of missing approvals is returned.
   *
   * If the group doesn't exist, or it is a user, or its membership is frozen, or the current user is a temporary user, the "forbidden" response is returned.
   *
   * If the group is a team and the user is already on a team that has attempts for same contest while the contest doesn't allow multiple attempts or that has active attempts for the same contest, the unprocessable entity error is returned.
   *
   * If the group is a team and joining breaks entry conditions of at least one of the team's participations (i.e. any of `entry_min_admitted_members_ratio` or `entry_max_team_size` would not be satisfied), the unprocessable entity error is returned.
   *
   * If `groups.enforce_max_participants` is true and the number of participants >= `groups.max_participants`, the conflict error is returned. (The number of participants is computed as the number of non-expired users or teams which are direct children
   *  of the group + invitations (join requests are not counted)).
   */
  groupJoinRequestCreate: {
    parameters: {
      path: {
        group_id: number;
      };
      query: {
        approvals?: ("personal_info_view" | "lock_membership" | "watch")[];
      };
    };
    responses: {
      201: responses["createdOrUnchangedResponse"];
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      409: responses["conflictResponse"];
      422: responses["unprocessableEntityResponseWithMissingApprovals"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Lets the current user withdraw a request to join a group (idenfified by {group_id}).
   *
   * On success the service removes a row  with `group_id` = `{group_id}`, `member_id` = user's self group id and `type` = 'join_request' from the `group_pending_requests` table, and creates a new row in `group_membership_changes` for the same group-user pair with `action` = 'join_request_withdrawn' and `at` equal to current UTC time.
   * * If there is no row in `group_pending_requests` for the group-user pair with
   *   `type` == 'join_request', the "not found" error is returned.
   */
  groupJoinRequestWithdraw: {
    parameters: {
      path: {
        group_id: number;
      };
    };
    responses: {
      200: responses["updatedResponse"];
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      422: responses["unprocessableEntityResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /** Returns groups for which the current user is a manager (subgroups are skipped) */
  managedGroupsView: {
    parameters: {
      query: {
        sort?: ("type" | "-type" | "name" | "-name" | "id" | "-id")[];
        /** Start the page from the group next to one with `id`=`{from.id}` */
        "from.id"?: number;
        /** Display the first N groups */
        limit?: number;
      };
    };
    responses: {
      /** OK. Success response with an array of managed groups */
      200: {
        schema: definitions["managedGroupsGetResponseRow"][];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /** Set users.notifications_read_at to NOW() for the current user */
  userNotificationReadDateUpdate: {
    responses: {
      200: responses["updatedResponse"];
      401: responses["unauthorizedResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /** Gets the user info from the login module and updates the local user info cache stored in the `users` table */
  userDataRefresh: {
    responses: {
      200: responses["updatedResponse"];
      401: responses["unauthorizedResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * The team identified by `{item_id}` i.e. a group which:
   *
   *   * has an active and unexpired attempt with `root_item_id` = `{item_id}`,
   *
   *   * is a direct parent (i.e. via `groups_groups`) of the authenticated user’s `selfGroup`,
   *
   *   * is of type "Team".
   *
   *
   * If there are several matching teams, returns the first one in the order of `groups.id`.
   */
  teamGetByItemID: {
    parameters: {
      path: {
        item_id: number;
      };
    };
    responses: {
      /** OK. Success response with the team's id */
      200: {
        schema: {
          group_id: number;
        };
      };
      401: responses["unauthorizedResponse"];
      404: responses["notFoundResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Creates a group with the input `name`, `type`, `created_at` = now(), and default values in other columns.
   *
   * Also, the service sets the authenticated user as a manager of the group with the highest level of permissions. After everything, it propagates group ancestors.
   *
   * The user should not be temporary, otherwise the "forbidden" response is returned.
   */
  groupCreate: {
    parameters: {
      body: {
        /** The group to create */
        data: definitions["createGroupRequest"];
      };
    };
    responses: {
      201: responses["createdWithIDResponse"];
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Returns the group identified by the given `group_id`.
   *
   * The `group_id` group should be visible to the current user, so it should be either an ancestor of a group he joined, or an ancestor of a non-user group he manages, or a descendant of a group he manages, or a public group, otherwise the 'forbidden' error is returned. If the group is a user, the 'forbidden' error is returned as well.
   *
   * Note: `code*` and `current_user_can_*` fields are omitted when the user is not a manager of the group.
   */
  groupGet: {
    parameters: {
      path: {
        group_id: number;
      };
    };
    responses: {
      /** OK. The group info */
      200: {
        schema: definitions["groupGetResponse"];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Updates group information.
   * Requires the user to be a manager of the group, otherwise the 'forbidden' error is returned.
   *
   * The user should have `can_manage` >= 'memberships' in order to modify `code_expires_at`, `code_lifetime`, `frozen_membership`, `max_participants`, or `enforce_max_participants`, otherwise the "bad request" error is returned. In order to modify values of other fields, the user should have `can_manage` >= 'memberships_and_group'.
   *
   * If the `root_activity_id` item is provided and is not null, the item should not be a skill and the user should have at least 'can_view:info' permission on it, otherwise the 'forbidden' error is returned.
   *
   * If the `root_skill_id` item is provided and is not null, the item should be a skill and the user should have at least 'can_view:info' permission on it, otherwise the 'forbidden' error is returned.
   *
   * If `is_official_session` is being changed to true, the user should have at least 'can_make_session_official' permission on the activity item, otherwise the 'forbidden' error is returned.
   *
   * Setting `is_official_session` to true while keeping `root_activity_id` not set or setting `root_activity_id` to null for an official session will cause the "bad request" error.
   *
   * Setting `enforce_max_participants` to true while keeping `max_participants` null or setting `max_participants` to null while keeping `enforce_max_participants` = true will cause the "bad request" error.
   *
   * Changing `require_personal_info_access_approval` to 'edit' will cause the "bad request" error.
   */
  groupUpdate: {
    parameters: {
      path: {
        group_id: number;
      };
      body: {
        "group information": definitions["groupUpdateInput"];
      };
    };
    responses: {
      200: responses["updatedResponse"];
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Removes a group, its parent-child relations and other objects linked to it.
   *
   * The service deletes `groups_groups`, `attempts`, `results`, `group_membership_changes`, `group_pending_requests`, `permissions_granted`, `permissions_generated`, and `filters` linked to the group. Access rights are updated accordingly too.
   *
   * Restrictions (otherwise the 'forbidden' error is returned):
   *   * the authenticated user should be a manager with `can_manage` = 'memberships_and_group' on the `{group_id}`,
   *   * the group should not be of type "User".
   *
   * Also, the group must be empty (no active subgroups of any type), otherwise the 'not found' error is returned.
   */
  groupDelete: {
    parameters: {
      path: {
        group_id: number;
      };
    };
    responses: {
      201: responses["deletedResponse"];
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      404: responses["notFoundResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Returns visible children of the group having types specified by `types_include` and `types_exclude` parameters.
   *
   * A group is visible if it is either 1) an ancestor of a group the current user joined, or 2) an ancestor of a non-user group he manages, or 3) a descendant of a group he manages, or 4) a public group.
   *
   * * The `group_id` should be visible to the current user.
   *
   * Note: `user_count` and `current_user_can_*` fields are omitted when the user is not a manager of the group.
   */
  groupChildrenView: {
    parameters: {
      path: {
        group_id: number;
      };
      query: {
        types_include?: (
          | "Class"
          | "Team"
          | "Club"
          | "Friends"
          | "Other"
          | "User"
          | "Session"
          | "Base"
        )[];
        types_exclude?: (
          | "Class"
          | "Team"
          | "Club"
          | "Friends"
          | "Other"
          | "User"
          | "Session"
          | "Base"
        )[];
        /** Start the page from the sub-group next to the sub-group with `id`=`{from.id}` */
        "from.id"?: number;
        sort?: (
          | "name"
          | "-name"
          | "type"
          | "-type"
          | "grade"
          | "-grade"
          | "id"
          | "-id"
        )[];
        /** Display the first N sub-groups */
        limit?: number;
      };
    };
    responses: {
      /** OK. Success response with an array of group's children */
      200: {
        schema: definitions["groupChildrenViewResponseRow"][];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Creates a new code using a set of allowed characters [3456789abcdefghijkmnpqrstuvwxy]. Makes sure it doesn’t correspond to any existing group code. Saves it for the given group and returns it.
   *
   * The authenticated user should be a manager of `group_id` with `can_manage` >= 'memberships', otherwise the 'forbidden' error is returned. If the group is a user, the 'forbidden' error is returned as well.
   */
  groupCodeCreate: {
    parameters: {
      path: {
        group_id: number;
      };
    };
    responses: {
      /** OK. The new code has been set. */
      200: {
        schema: {
          code: string;
        };
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Removes the code of the given group (which prevents joining by code)
   *
   * The authenticated user should be a manager of `group_id` with `can_manage` >= 'memberships', otherwise the 'forbidden' error is returned. If the group is a user, the 'forbidden' error is returned as well.
   */
  groupCodeRemove: {
    parameters: {
      path: {
        group_id: number;
      };
    };
    responses: {
      200: responses["deletedResponse"];
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * List all permissions granted to a group and its ancestors or to its descendants. Only permissions granted on items for which the current user has `can_grant_view` > 'none' or `can_watch` = 'answer_with_grant' or `can_edit` = 'all_with_grant' are displayed.
   *
   * When `{descendants}` is 0, source groups of permissions are ancestors of the `group_id` group (including the group itself) managed by the current user with `can_grant_group_access` permission.
   * When `{descendants}` is 1, source groups of permissions are ancestors of the `group_id` group (including the group itself) or descendants of the `group_id` group managed by the current user with `can_grant_group_access` permission.
   * * The current user must be a manager (with `can_grant_group_access` permission) of `{group_id}`.
   */
  grantedPermissionsView: {
    parameters: {
      path: {
        group_id: number;
      };
      query: {
        /** If equal to 1, the results are permissions granted to the group's descendants (not including the group itself), otherwise the results are permissions granted to the group's ancestors (including the group itself). */
        descendants?: 0 | 1;
        sort?: (
          | "source_group.name"
          | "-source_group.name"
          | "group.name"
          | "-group.name"
          | "item.title"
          | "-item.title"
          | "source_group.id"
          | "-source_group.id"
          | "group.id"
          | "-group.id"
          | "item.id"
          | "-item.id"
        )[];
        /** Start the page from permissions next to the permissions with `source_group_id`=`{from.source_group.id}` (`{from.item.id}` and `{from.group.id}` should be given too when `{from.source_group.id}` is given) */
        "from.source_group.id"?: number;
        /** Start the page from permissions next to the permissions with `group_id`=`{from.group.id}` (`{from.item.id}` and `{from.source_group.id}` should be given too when `{from.group.id}` is given) */
        "from.group.id"?: number;
        /** Start the page from permissions next to the permissions with `item_id`=`{from.item.id}` (`{from.group.id}` and `{from.source_group.id}` should be given too when `{from.item.id}` is given) */
        "from.item.id"?: number;
        /** Display the first N permissions */
        limit?: number;
      };
    };
    responses: {
      /** OK. Granted permissions */
      200: {
        schema: definitions["grantedPermissionsViewResultRow"][];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Returns the current progress of a group on a subset of items.
   *
   * For each item from `{parent_item_id}` and its visible children, displays the result of each direct child of the given `group_id` whose type is not in (Team, User).
   *
   * Restrictions:
   * * The current user should be a manager of the group (or of one of its ancestors) with `can_watch_members` set to true,
   * * The current user should have `can_watch_members` >= 'result' on each of `{parent_item_ids}` items,
   *
   * otherwise the 'forbidden' error is returned.
   */
  groupGroupProgress: {
    parameters: {
      path: {
        group_id: number;
      };
      query: {
        parent_item_ids: number[];
        /** Start the page from the group next to the group with `id`=`{from.id}` */
        "from.id"?: number;
        /** Display results for the first N groups (sorted by `name`) */
        limit?: number;
      };
    };
    responses: {
      /** OK. Success response with groups progress on items For each item from `{parent_item_id}` and its visible children, displays the result for each direct child of the given group_id whose type is not in (Team, User). Values are averages of all the group's "end-members" where “end-member” defined as descendants of the group which are either 1) teams or 2) users who descend from the input group not only through teams (one or more). */
      200: {
        schema: definitions["groupGroupProgressResponseTableCell"][];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Returns the current progress of a group on a subset of items.
   *
   * For each item from `{parent_item_id}` and its visible children, displays the average result of each direct child of the given `group_id` whose type is not in (Team, User).
   *
   * Restrictions:
   * * The current user should be a manager of the group (or of one of its ancestors) with `can_watch_members` set to true,
   * * The current user should have `can_watch_members` >= 'result' on each of `{parent_item_ids}` items,
   *
   * otherwise the 'forbidden' error is returned.
   */
  groupGroupProgressCSV: {
    parameters: {
      path: {
        group_id: number;
      };
      query: {
        parent_item_ids: number[];
      };
    };
    responses: {
      /** OK. Success response with users progress on items */
      200: unknown;
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Lists managers of the given group and (optionally) managers of its ancestors (rows from the `group_managers` table with `group_id` = `{group_id}`) including managers' names.
   *
   * The authenticated user should be a manager of the `group_id` group or a member of the group or of its descendant, otherwise the 'forbidden' error is returned.
   */
  groupManagersView: {
    parameters: {
      path: {
        group_id: number;
      };
      query: {
        /** If equal to 1, the results include managers of all ancestor groups */
        include_managers_of_ancestor_groups?: 0 | 1;
        sort?: ("name" | "-name" | "id" | "-id")[];
        /** Start the page from the manager next to the manager with `groups.id`=`{from.id}` */
        "from.id"?: number;
        /** Display the first N managers */
        limit?: number;
      };
    };
    responses: {
      /** OK. The array of group managers */
      200: {
        schema: definitions["groupManagersViewResponseRow"][];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Modifies permissions of a group manager.
   *
   * The authenticated user should have 'can_manage:memberships_and_group' permission on the group and the `{group_id}`-`{manager_id}` pair should exist in `group_managers, otherwise the "forbidden" error is returned.
   */
  groupManagerEdit: {
    parameters: {
      path: {
        group_id: number;
        manager_id: number;
      };
      body: {
        /** New permissions of the manager */
        data: definitions["createGroupManagerRequest"];
      };
    };
    responses: {
      200: responses["updatedResponse"];
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Makes a user a group manager with given permissions.
   *
   * The authenticated user should have 'can_manage:memberships_and_group' permission on the group and `{manager_id}` should exist, otherwise the "forbidden" error is returned.
   */
  groupManagerCreate: {
    parameters: {
      path: {
        group_id: number;
        manager_id: number;
      };
      body: {
        /** Permissions of the new manager */
        data: definitions["createGroupManagerRequest"];
      };
    };
    responses: {
      /** Created. The request has successfully added a user as a manager. */
      201: {
        schema: definitions["createdResponse"];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Removes a group manager.
   *
   * The authenticated user should be the manager represented by `{manager_id}` or have 'can_manage:memberships_and_group' permission on the group and the `{group_id}`-`{manager_id}` pair should exist in `group_managers, otherwise the "forbidden" error is returned.
   */
  groupManagerDelete: {
    parameters: {
      path: {
        group_id: number;
        manager_id: number;
      };
    };
    responses: {
      200: responses["deletedResponse"];
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Returns a list of users that are members of the group. The output contains basic user info (`first_name` and `last_name` are only shown for the authenticated user or if the user approved access to their personal info for some group managed by the authenticated user).
   *
   * The authenticated user should be a manager of `{group_id}`, otherwise the 'forbidden' error is returned.
   */
  groupsMembersView: {
    parameters: {
      path: {
        group_id: number;
      };
      query: {
        sort?: (
          | "member_since"
          | "-member_since"
          | "user.login"
          | "-user.login"
          | "user.grade"
          | "-user.grade"
          | "id"
          | "-id"
        )[];
        /** Start the page from the member next to the member with `groups.id`=`{from.id}` */
        "from.id"?: number;
        /** Display the first N members */
        limit?: number;
      };
    };
    responses: {
      /** OK. The array of group members */
      200: {
        schema: definitions["groupsMembersViewResponseRow"][];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Lets an admin remove users from a group. On success the service removes relations from `groups_groups` and creates `group_membership_changes` rows with `action` = 'removed and `at` = current UTC time for each of `user_ids`. It also refreshes the access rights.
   *
   * The authenticated user should be a manager of the `group_id` with `can_manage` >= 'memberships', otherwise the 'forbidden' error is returned. If the group is a user, the 'forbidden' error is returned as well.
   *
   * Each of the input `user_ids` should have the input `group_id` as a parent in `groups_groups`, otherwise the `user_id` gets skipped with `invalid` as the result.
   *
   * The response status code on success (200) doesn't depend on per-group results.
   */
  groupRemoveMembers: {
    parameters: {
      path: {
        group_id: number;
      };
      query: {
        user_ids: number[];
      };
    };
    responses: {
      /** OK. Success response with the per-user deletion statuses */
      200: {
        schema: {
          /** `user_id` -> `result` */
          data: {
            [key: string]: "invalid" | "success" | "unchanged" | "not_found";
          };
          /** success */
          message: "success";
          /** true */
          success: string;
        };
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Lists child groups visible to the user, so either 1) ancestors of a group he joined, or 2) ancestors of a non-user group he manages, or 3) descendants of a group he manages, or 4) groups with `is_public` = 1. Ordered alphabetically by name.
   *
   * The input group should be visible to the current user with the same definition as above, otherwise the 'forbidden' error is returned. If the group is a user, the 'forbidden' error is returned as well.
   */
  groupNavigationView: {
    parameters: {
      path: {
        group_id: number;
      };
      query: {
        /** Display the first N children */
        limit?: number;
      };
    };
    responses: {
      /** OK. Success response with an array root groups */
      200: {
        schema: definitions["groupNavigationViewResponse"];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Finds a path from any of root groups to a given group.
   *
   * A path is an array of group ids from a visible group root (a visible non-"base" group without non-"base" parent) to the input group. Each group must be visible, so either 1) ancestors of groups he joined, 2) ancestors of non-user groups he manages, 3) descendants of groups he manages, 4) groups with is_public=1. Of all possible paths the service chooses any of shortest ones.
   *
   * At least one path should exist, otherwise the 'forbidden' error is returned.
   */
  groupPathFromRootFind: {
    parameters: {
      path: {
        group_id: number;
      };
    };
    responses: {
      /** OK. Success response with the found group path */
      200: {
        schema: {
          path: string[];
        };
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Returns a list of group requests and invitations (rows from the `group_membership_changes` table with `group_id` = `{group_id}` and `action` = "invitation_created"/"join_request_created"/"invitation_refused"/"join_request_refused") with basic info on joining (invited/requesting) users and inviting users.
   *
   * When `old_rejections_weeks` is given, only those rejected invitations/requests (`group_membership_changes.action` is "invitation_refused" or "join_request_refused") are shown that are created in the last `old_rejections_weeks` weeks. Otherwise all rejected invitations/requests are shown.
   *
   * `first_name` and `last_name` are only shown for joining users whose personal info is visible to the current user. A user can see personal info of his own and of those members/candidates of his managed groups who have provided view access to their personal data.
   *
   * Inviting users are displayed only if `group_membership_changes.action` = "invitation_created".
   *
   * The authenticated user should be a manager of `group_id` with `can_manage` >= 'memberships', otherwise the 'forbidden' error is returned. If the group is a user, the 'forbidden' error is returned as well.
   */
  groupRequestsView: {
    parameters: {
      path: {
        group_id: number;
      };
      query: {
        old_rejections_weeks?: number;
        sort?: (
          | "at"
          | "-at"
          | "joining_user.login"
          | "-joining_user.login"
          | "action"
          | "-action"
          | "member_id"
          | "-member_id"
        )[];
        /** Start the page from the request/invitation next to the request/invitation with `group_membership_changes.at` = `{from.at}` (`{from.member_id}` is also required if `{from.at}` is given) */
        "from.at"?: string;
        /** Start the page from the request/invitation next to the request/invitation with `group_membership_changes.member_id`=`{from.member_id}` (`{from.at}` is also required if `{from.member_id}` is given) */
        "from.member_id"?: number;
        /** Display the first N requests/invitations */
        limit?: number;
      };
    };
    responses: {
      /** OK. The array of group requests/invitations */
      200: {
        schema: definitions["groupRequestsViewResponseRow"][];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Returns all teams (`type` = "Team") among the descendants of the given group
   *
   * `first_name` and `last_name` of descendant team members are only visible to the members themselves and to managers of those groups to which those members provided view access to personal data.
   *
   * * The authenticated user should be a manager of the parent group.
   */
  groupTeamDescendantView: {
    parameters: {
      path: {
        group_id: number;
      };
      query: {
        /** Start the page from the team next to the team with `id`=`{from.id}` */
        "from.id"?: number;
        sort?: ("name" | "-name" | "id" | "-id")[];
        /** Display the first N teams */
        limit?: number;
      };
    };
    responses: {
      /** OK. Success response with an array of teams */
      200: {
        schema: definitions["teamDescendant"][];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Returns the current progress of teams on a subset of items.
   *
   * For each item from `{parent_item_id}` and its visible children, displays the result of each team among the descendants of the group.
   *
   * Restrictions:
   * * The current user should be a manager of the group (or of one of its ancestors) with `can_watch_members` set to true,
   * * The current user should have `can_watch_members` >= 'result' on each of `{parent_item_ids}` items,
   *
   * otherwise the 'forbidden' error is returned.
   */
  groupTeamProgress: {
    parameters: {
      path: {
        group_id: number;
      };
      query: {
        parent_item_ids: number[];
        /** Start the page from the team next to the team with `id`=`{from.id}` */
        "from.id"?: number;
        /** Display results for the first N teams (sorted by `name`) */
        limit?: number;
      };
    };
    responses: {
      /** OK. Success response with teams progress on items */
      200: {
        schema: definitions["groupTeamProgressResponseTableCell"][];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Returns the current progress of teams on a subset of items.
   *
   * For each item from `{parent_item_id}` and its visible children, displays the result of each team among the descendants of the group.
   *
   * Restrictions:
   * * The current user should be a manager of the group (or of one of its ancestors) with `can_watch_members` set to true,
   * * The current user should have `can_watch_members` >= 'result' on each of `{parent_item_ids}` items,
   *
   * otherwise the 'forbidden' error is returned.
   */
  groupTeamProgressCSV: {
    parameters: {
      path: {
        group_id: number;
      };
      query: {
        parent_item_ids: number[];
      };
    };
    responses: {
      /** OK. Success response with users progress on items */
      200: unknown;
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Lists the user-batch prefixes  with `allow_new` = 1 matching the input group's ancestors that are managed by the current user with 'can_manage:membership' permission (i.e., the `group_id` is a descendant of `user_batch_prefixes.group_id`).
   *
   * The authenticated user should be a manager of `group_id` with 'can_manage:membership' permission at least, otherwise the 'forbidden' error is returned. If the group is a user, the 'forbidden' error is returned as well.
   */
  userBatchPrefixesView: {
    parameters: {
      path: {
        group_id: number;
      };
      query: {
        sort?: ("group_prefix" | "-group_prefix")[];
        /** Start the page from the prefix next to the prefix with `user_batch_prefixes.group_prefix` = `{from.group_prefix}` */
        "from.group_prefix"?: string;
        /** Display the first N user-batch prefixes */
        limit?: number;
      };
    };
    responses: {
      /** OK. The array of user-batch prefixes */
      200: {
        schema: definitions["userBatchPrefix"][];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Return all users (`type` = "User") among the descendants of the given group
   *
   * `first_name` and `last_name` of descendant users are only visible to the users themselves and to managers of those groups to which those users provided view access to personal data.
   *
   * * The authenticated user should be a manager of the parent group.
   */
  groupUserDescendantView: {
    parameters: {
      path: {
        group_id: number;
      };
      query: {
        /** Start the page from the user next to the user with `group_id`=`{from.id}` */
        "from.id"?: number;
        sort?: ("name" | "-name" | "id" | "-id")[];
        /** Display the first N teams */
        limit?: number;
      };
    };
    responses: {
      /** OK. Success response with an array of users */
      200: {
        schema: definitions["userDescendant"][];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Returns the current progress of users on a subset of items.
   *
   * For each item from `{parent_item_id}` and its visible children, displays the result of all user self-groups among the descendants of the given group (including those in teams).
   *
   * For each user, only the result corresponding to his best score counts (across all his teams and his own results) disregarding whether or not the score was done in a team which is descendant of the input group.
   *
   * Restrictions:
   * * The current user should be a manager of the group (or of one of its ancestors) with `can_watch_members` set to true,
   * * The current user should have `can_watch` >= 'result' on each of `{parent_item_ids}` items,
   *
   * otherwise the 'forbidden' error is returned.
   */
  groupUserProgress: {
    parameters: {
      path: {
        group_id: number;
      };
      query: {
        parent_item_ids: number[];
        /** Start the page from the user next to the user with `groups.id`=`{from.id}` */
        "from.id"?: number;
        /** Display results for the first N users (sorted by `groups.name`) */
        limit?: number;
      };
    };
    responses: {
      /** OK. Success response with users progress on items */
      200: {
        schema: definitions["groupUserProgressResponseTableCell"][];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Returns the current progress of users on a subset of items.
   *
   * For each item from `{parent_item_id}` and its visible children, displays the result of all user self-groups among the descendants of the given group (including those in teams).
   *
   * For each user, only the result corresponding to his best score counts (across all his teams and his own results) disregarding whether or not the score was done in a team which is descendant of the input group.
   *
   * Restrictions:
   * * The current user should be a manager of the group (or of one of its ancestors) with `can_watch_members` set to true,
   * * The current user should have `can_watch` >= 'result' on each of `{parent_item_ids}` items,
   *
   * otherwise the 'forbidden' error is returned.
   */
  groupUserProgressCSV: {
    parameters: {
      path: {
        group_id: number;
      };
      query: {
        parent_item_ids: number[];
      };
    };
    responses: {
      /** OK. Success response with users progress on items */
      200: unknown;
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Returns brief information for groups listed in `ids`.
   *
   * Each group must be visible to the current user, so it should be either
   *
   *   1. an ancestor of a group the current user joined, or
   *   2. an ancestor of a non-user group he manages, or
   *   3. a descendant of a group he manages, or
   *   4. a group with is_public=1,
   *
   * otherwise the 'forbidden' error is returned. Also, there must be no duplicates in the list.
   */
  groupBreadcrumbsView: {
    parameters: {
      path: {
        /** slash-separated list of IDs (no more than 10 IDs allowed) */
        ids: string;
      };
    };
    responses: {
      /** OK. Success response with an array of group information */
      200: {
        schema: definitions["groupBreadcrumbsViewResponseRow"][];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Lets an admin invite users, based on list of their logins, to join a group (identified by {parent_group_id}). On success the service creates new rows in `group_pending_requests` with
   * * `type` = "invitation"
   * * `at` = current UTC time
   * and `group_membership_changes` with
   * * `action` = "invitation_created"
   * * `at` = current UTC time.
   * * `initiator_id` = `users.group_id` of the authorized user.
   *
   * It also refreshes the access rights when needed.
   *
   * * Logins not corresponding to valid users or corresponding to temporary users are ignored (result = "not_found").
   * * If the `parent_group_id` corresponds to a team, the service skips users who are members of other teams participating in same contests as `parent_group_id` (expired/ended attempts are ignored for contests allowing multiple attempts, result = "in_another_team").
   * * Pending group requests from users listed in `logins` become accepted (result = "success") if all needed approvals are given, or replaced by invitations otherwise.
   * * Pending invitations stay unchanged (result = "unchanged).
   * * Group members (already having `groups_groups`) are skipped (result = "invalid").
   *
   * The action should not create cycles in the groups relations graph, otherwise the login gets skipped with `cycle` as the result.
   *
   * If `groups.enforce_max_participants` is true and the new number of participants exceeds `groups.max_participants`, all the valid logins get skipped with `full` as the result. (The number of participants is computed as the number of non-expired users or teams which are direct children of the group + invitations (join requests are not counted)).
   *
   * The response status code on success (201) doesn't depend on per-group results.
   *
   * The authenticated user should be a manager of the `parent_group_id` with `can_manage` >= 'memberships', otherwise the 'forbidden' error is returned. If the group is a user, the 'forbidden' error is returned as well.
   */
  groupInvitationsCreate: {
    parameters: {
      path: {
        parent_group_id: number;
      };
      body: {
        logins_info: {
          logins: string[];
        };
      };
    };
    responses: {
      201: responses["createdLoginRelationsResponse"];
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Lets a manager withdraw invitations (of users with ids in {group_ids}) to join a group (idenfified by {parent_group_id}). On success the service removes rows with `type` = 'invitation' from `group_pending_requests` and creates new rows with `action` = 'invitation_withdrawn' and `at` = current UTC time in `group_membership_changes` for each of `group_ids`.
   *
   * The authenticated user should be a manager of the `parent_group_id` with `can_manage` >= 'memberships', otherwise the 'forbidden' error is returned. If the group is a user, the 'forbidden' error is returned as well.
   *
   * There should be a row with `type` = 'invitation' and `group_id` = `{parent_group_id}` in `group_pending_requests` for each of the input `group_ids`, otherwise the `group_id` gets skipped with `invalid` as the result.
   *
   * The response status code on success (200) doesn't depend on per-group results.
   */
  groupInvitationsWithdraw: {
    parameters: {
      path: {
        parent_group_id: number;
      };
      query: {
        group_ids: number[];
      };
    };
    responses: {
      200: responses["updatedGroupRelationsResponse"];
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Lets an admin approve user requests (identified by `{group_ids}`) to join a group (identified by {parent_group_id}). On success the service creates new `groups_groups` rows with `parent_group_id` = `{parent_group_id}` and new `group_membership_changes` with `group_id` = `{parent_group_id}`, `action` = 'join_request_accepted`, `at` = current UTC time for each of `group_ids`. The `groups_groups.*_approved_at` fields are set to `group_pending_requests.at` for each approval given in the pending join requests. Then the appropriate pending requests get removed from `group_pending_requests`. The service also refreshes the access rights.
   *
   * The authenticated user should be a manager of the `{parent_group_id}` with `can_manage` >= 'memberships', otherwise the 'forbidden' error is returned. If the group is a user or if the group membership is frozen, the 'forbidden' error is returned as well.
   *
   * If the `{parent_group_id}` corresponds to a team, `{group_ids}` can contain no more than one id, otherwise the 'bad request' response is returned.
   *
   * If the `{parent_group_id}` corresponds to a team, the service skips a user being a member of another team having attempts for the same contest as `{parent_group_id}` (expired attempts are ignored for contests allowing multiple attempts, result = "in_another_team").
   *
   * If the `{parent_group_id}` corresponds to a team, the service skips a user with result = "in_another_team" if joining breaks entry conditions of at least one of the team's participations (i.e. any of `entry_min_admitted_members_ratio` or `entry_max_team_size` would not be satisfied).
   *
   * There should be a row with `type` = 'join_request' and `group_id` = `{parent_group_id}` in `group_pending_requests` for each of the input `group_ids`, otherwise the `group_id` gets skipped with 'invalid' as the result.
   *
   * If the `{parent_group_id}` requires any approvals, but the pending request doesn't contain them, the `group_id` gets skipped with 'approvals_missing' as the result.
   *
   * The action should not create cycles in the groups relations graph, otherwise the `group_id` gets skipped with `cycle` as the result.
   *
   * If `groups.enforce_max_participants` is true and the new number of participants exceeds `groups.max_participants` for the `{parent_group_id}` group, all the valid joining groups get skipped with `full` as the result. (The number of participants is computed as the number of non-expired users or teams which are direct children of the group + invitations (join requests are not counted)).
   *
   * The response status code on success (200) doesn't depend on per-group results.
   */
  groupJoinRequestsAccept: {
    parameters: {
      path: {
        parent_group_id: number;
      };
      query: {
        group_ids: number[];
      };
    };
    responses: {
      200: responses["updatedGroupRelationsResponse"];
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Lets an admin reject requests (of users with ids in {group_ids}) to join a group (identified by {parent_group_id}). On success the service removes rows with `type` = 'join_request' from `group_pending_requests` and creates new rows with `action` = 'join_request_refused' and `at` = current UTC time in `group_membership_changes` for each of `group_ids`.
   *
   * The authenticated user should be a manager of the `parent_group_id` with `can_manage` >= 'memberships', otherwise the 'forbidden' error is returned. If the group is a user, the 'forbidden' error is returned as well.
   *
   * There should be a row with `type` = 'join_request' and `group_id` = `{parent_group_id}` in `group_pending_requests` for each of the input `group_ids`, otherwise the `group_id` gets skipped with `invalid` as the result.
   *
   * The response status code on success (200) doesn't depend on per-group results.
   */
  groupJoinRequestsReject: {
    parameters: {
      path: {
        parent_group_id: number;
      };
      query: {
        group_ids: number[];
      };
    };
    responses: {
      200: responses["updatedGroupRelationsResponse"];
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Lets an admin approve user requests (identified by `{group_ids}`) to leave a group (identified by {parent_group_id}). On success the service removes `groups_groups` rows with `parent_group_id` = `{parent_group_id}` and creates new `group_membership_changes` with `group_id` = `{parent_group_id}`, `action` = 'leave_request_accepted`, `at` = current UTC time for each of `group_ids` The appropriate pending requests get removed from `group_pending_requests`. The service also refreshes the access rights.
   *
   * The authenticated user should be a manager of the `{parent_group_id}` with `can_manage` >= 'memberships', otherwise the 'forbidden' error is returned.  If the group is a user or the group membership is frozen, the 'forbidden' error is returned as well.
   *
   * There should be a row with `type` = 'leave_request' and `group_id` = `{parent_group_id}` in `group_pending_requests` for each of the input `group_ids`, otherwise the `group_id` gets skipped with `invalid` as the result.
   *
   * If the `{parent_group_id}` corresponds to a team, `{group_ids}` can contain no more than one id, otherwise the 'bad request' response is returned.
   *
   * If the `{parent_group_id}` corresponds to a team, the service skips a user with result = "in_another_team" if removal breaks entry conditions of at least one of the team's participations (i.e. any of `entry_min_admitted_members_ratio` or `entry_max_team_size` would not be satisfied).
   *
   * The response status code on success (200) doesn't depend on per-group results.
   */
  groupLeaveRequestsAccept: {
    parameters: {
      path: {
        parent_group_id: number;
      };
      query: {
        group_ids: number[];
      };
    };
    responses: {
      200: responses["updatedGroupRelationsResponse"];
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Lets an admin reject requests (of users with ids in {group_ids}) to leave a group (identified by {parent_group_id}). On success the service removes rows with `type` = 'leave_request' from `group_pending_requests` and creates new rows with `action` = 'leave_request_refused' and `at` = current UTC time in `group_membership_changes` for each of `group_ids`.
   *
   * The authenticated user should be a manager of the `parent_group_id` with `can_manage` >= 'memberships', otherwise the 'forbidden' error is returned. If the group is a user, the 'forbidden' error is returned as well.
   *
   * There should be a row with `type` = 'leave_request' and `group_id` = `{parent_group_id}` in `group_pending_requests` for each of the input `group_ids`, otherwise the `group_id` gets skipped with `invalid` as the result.
   *
   * The response status code on success (200) doesn't depend on per-group results.
   */
  groupLeaveRequestsReject: {
    parameters: {
      path: {
        parent_group_id: number;
      };
      query: {
        group_ids: number[];
      };
    };
    responses: {
      200: responses["updatedGroupRelationsResponse"];
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Add a group as a child to another group. Lets a group admin add another group as a child and refreshes the access rights afterwards.
   *
   * Restrictions (otherwise the 'forbidden' error is returned):
   *   * the authenticated user should be a manager of both `parent_group_id` and `child_group_id,
   *   * the authenticated user should have `can_manage` >= 'memberships' on the `parent_group_id`,
   *   * the authenticated user should have `can_manage` = 'memberships_and_group' on the `child_group_id`,
   *   * the parent group should not be of type "User" or "Team",
   *   * the child group should not be of types "Base" or "User"
   *     (since users should join groups only by code or by invitation/request),
   *   * the action should not create cycles in the groups relations graph.
   */
  groupAddChild: {
    parameters: {
      path: {
        parent_group_id: number;
        child_group_id: number;
      };
    };
    responses: {
      /** Created. The request has successfully created the group relation. */
      201: {
        schema: definitions["createdResponse"];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Removes a child group from a parent group and optionally deletes that group and its subgroups.
   *
   * Deletes the relation from `groups_groups`. If `{delete_orphans}` is true and the child group becomes an orphan then the service also deletes that group, its parent-child relations, and recursively deletes each new orphaned group.
   *
   * If `{delete_orphans}` is false and the child removal makes it an orphan (it doesn't have other parent groups), the service deletes the relation keeping the orphaned child group.
   *
   * If a group gets deleted, the service also deletes `groups_groups`, `attempts`, `results`, `group_membership_changes`, `group_pending_requests`, `permissions_granted`, `permissions_generated`, and `filters` linked to the group. Access rights are updated accordingly too.
   *
   * Restrictions (otherwise the 'forbidden' error is returned):
   *   * the authenticated user should be a manager of both `{parent_group_id}` and `{child_group_id}`,
   *   * the authenticated user should have `can_manage` >= 'memberships' on the `{parent_group_id}`,
   *   * the parent group should not be of type "User" or "Team",
   *   * the child group should not be of types "Base" or "User"
   *     (since there are more appropriate services for removing users from groups: groupLeave and groupRemoveMembers).
   */
  groupRemoveChild: {
    parameters: {
      path: {
        parent_group_id: number;
        child_group_id: number;
      };
      query: {
        delete_orphans?: 0 | 1;
      };
    };
    responses: {
      201: responses["deletedResponse"];
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Lets a manager of a group view permissions on an item for the group.
   * * The current user must be a manager (with `can_grant_group_access` permission) of `{source_group_id}` which should be an ancestor of the `{group_id}`.
   * * The current user must have `can_grant_view` > 'none' or `can_watch` = 'answer_with_grant' or `can_edit` = 'all_with_grant' on `{item_id}` on the item.
   */
  permissionsView: {
    parameters: {
      path: {
        group_id: number;
        source_group_id: number;
        item_id: number;
      };
    };
    responses: {
      /** OK. Permissions for the group */
      200: {
        schema: definitions["permissionsViewResponse"];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Let a manager of a group give/withdraw permissions on an item to a group.
   * * The user giving the access must be a manager (with `can_grant_group_access` permission) of `{source_group_id}` which should be an ancestor of the `{group_id}`.
   * * The user giving the access must have `permissions_generated.can_grant_view` >= given `can_view` for the item.
   * * The group must already have access to one of the parents of the item or the item itself.
   */
  updatePermissions: {
    parameters: {
      path: {
        group_id: number;
        source_group_id: number;
        item_id: number;
      };
      body: {
        "access rights information": definitions["updatePermissionsInput"];
      };
    };
    responses: {
      200: responses["updatedResponse"];
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Checks if it is possible for the current user (or for a new user if the current user is temporary) to join a group with the given code. The service returns false:
   * * if there is no group with `code_expires_at` > NOW() (or NULL), `code` = `{code}`, and `type` != 'User'
   *   (`reason` = 'no_group');
   *
   * * if the group is a team and the user is already on a team that has attempts for same contest
   *   while the contest doesn't allow multiple attempts or that has active attempts for the same contest
   *   (`reason` = 'conflicting_team_participation'),
   *
   * * if the group membership is frozen (`reason` = 'frozen_membership');
   * * if there is already an active row in `groups_groups` with the found group as a parent
   *   and the user’s id as a child (`reason` = 'already_member');
   *
   * * if the group is a team and joining breaks entry conditions of at least one of the team's participations
   *   (i.e. any of `entry_min_admitted_members_ratio` or `entry_max_team_size` would not be satisfied)
   *   (`reason` = 'team_conditions_not_met').
   *
   * Otherwise, the service returns true.
   */
  groupsCodeCheck: {
    parameters: {
      query: {
        code: string;
      };
    };
    responses: {
      /** OK. Validity of the code and additional info */
      200: {
        schema: definitions["groupCodeCheckResponse"];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /** Searches for groups that can be added as subgroups, based on a substring of their name. Returns groups for which the user is a manager with `can_manage` = 'memberships_and_group', whose `name` has `{search}` as a substring. */
  groupsPossibleSubgroupsSearch: {
    parameters: {
      query: {
        search: string;
        sort?: ("id" | "-id")[];
        /** Start the page from the group next to one with `groups.id`=`{from.id}` */
        "from.id"?: number;
        /** Display the first N groups */
        limit?: number;
      };
    };
    responses: {
      /** OK. Success response with an array of found groups */
      200: {
        schema: {
          /** Nullable */
          description: string;
          id: string;
          name: string;
          type:
            | "Class"
            | "Team"
            | "Club"
            | "Friends"
            | "Other"
            | "User"
            | "Base";
        }[];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /** Returns groups which are ancestors of a joined groups or managed non-user groups and do not have parents, not considering "type='Base'" groups */
  groupRootsView: {
    responses: {
      /** OK. Success response with an array of root groups */
      200: {
        schema: definitions["groupRootsViewResponseRow"][];
      };
      401: responses["unauthorizedResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Returns a list of group pending requests created by users with types listed in `{types}` (rows from the `group_pending_requests` table) with basic info on joining/leaving users for the group (if `{group_id}` is given) and its descendants (if `{group_id}` is given and `{include_descendant_groups}` is 1) or for all groups the current user can manage (`can_manage` >= 'memberships') (if `{group_id}` is not given).
   *
   * `first_name` and `last_name` are only shown for users whose personal info is visible to the current user. A user can see personal info of his own and of those members/candidates of his managed groups who have provided view access to their personal data.
   *
   * If `{group_id}` is given, the authenticated user should be a manager of `group_id` with `can_manage` >= 'memberships', otherwise the 'forbidden' error is returned. If the group is a user, the 'forbidden' error is returned as well.
   */
  groupUserRequestsView: {
    parameters: {
      query: {
        group_id?: number;
        include_descendant_groups?: 0 | 1;
        types?: ("join_request" | "leave_request")[];
        sort?: (
          | "at"
          | "-at"
          | "user.login"
          | "-user.login"
          | "group.name"
          | "-group.name"
          | "user.group_id"
          | "-user.group_id"
          | "group.id"
          | "-group.id"
        )[];
        /** Start the page from the request next to the request with `group_pending_requests.group_id`=`{from.group.id}` (only if `{group_id}` is not given; `{from.user.group_id}` is also required when `{from.group.id}` is given) */
        "from.group.id"?: number;
        /** Start the page from the request next to the request with `group_pending_requests.member_id`=`{from.user.group_id}` (`{from.group.id}` is also required if `{from.user.group_id}` is given and either `{group_id}` is not given or descendants are included) */
        "from.user.group_id"?: number;
        /** Display the first N requests */
        limit?: number;
      };
    };
    responses: {
      /** OK. The array of pending group requests */
      200: {
        schema: definitions["groupUserRequestsViewResponseRow"][];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Creates an item with parameters from the input data with `items.default_language_tag` = `language_tag`. Also it
   *
   *   * inserts a row into `items_strings` with given `language_tag`, `title`, `image_url`, `subtitle`, `description`,
   *
   *   * gives full access to the item for the current user (creates a new `permissions_granted` row with: `item_id` = `items.id`,
   *     `group_id` = `group_id` of the current user, `source_group_id` = `users.group_id` of the current user, `origin` = 'self',
   *     `is_owner` = 1).
   *
   *   * adds new relations for the parent and (optionally) children items into `items_items` and propagates `permissions_generated`.
   *     (The only allowed parent-child relations are skills-*, chapter-task, chapter-course, chapter-chapter.
   *     Otherwise the "bad request" error is returned.)
   *
   *   * (if `requires_explicit_entry` is true) creates a participants group, links `participants_group_id` to it,
   *     and gives this group 'can_view:content' permission on the new item.
   *
   * The user should have
   *
   *   * `can_view` >= 'content' and `can_edit` >= 'children' on the `parent.item_id`,
   *   * `can_view` != 'none' on the `children` items (if any),
   *
   * otherwise the "bad request" response is returned.
   *
   * The current user should not be temporary, otherwise the "forbidden" error response is returned.
   *
   * At least one of `parent` and `as_root_of_group_id` should be given, otherwise the "bad request" error response is returned.
   */
  itemCreate: {
    parameters: {
      body: {
        /** The item to create */
        data: definitions["itemCreateRequest"];
      };
    };
    responses: {
      201: responses["createdWithIDResponse"];
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Returns rows from `answers` and started/validated `results` with additional info on users and items for the participant or the `{watched_group_id}` group (only one of `{as_team_id}` and `{watched_group_id}` can be given).
   *
   * If possible, items titles are shown in the authenticated user's default language. Otherwise, the item's default language is used.
   *
   * `first_name` and `last_name` of users are only visible to the users themselves and to managers of those users' groups to which they provided view access to personal data.
   *
   * If `{watched_group_id}` is given, all rows of the result are related to descendant groups of `{watched_group_id}` and items that are descendants of `{ancestor_item_id}` (+ `{ancestor_item_id}` itself) and visible to the current user (at least 'info' access with `can_watch` >= 'result').
   *
   * If `{watched_group_id}` is not given, all rows of the result are related to the participant group (the current user or `{as_team_id}`) and items that are descendants of `{ancestor_item_id}` (+ `{ancestor_item_id}` itself) and visible to the current user (at least 'info' access).
   */
  itemActivityLogForItem: {
    parameters: {
      path: {
        ancestor_item_id: number;
      };
      query: {
        as_team_id?: number;
        /** The current user should be a manager of the watched group with `can_watch_members` = true, otherwise the 'forbidden' error is returned */
        watched_group_id?: number;
        /** Start the page from the row next to the row with `item_id`=`{from.item_id}` (all other `{from.*}` parameters are required when `{from.item_id}` is present) */
        "from.item_id"?: number;
        /** Start the page from the row next to the row with `participant_id`=`{from.participant_id}` (all other `{from.*}` parameters are required when `{from.participant_id}` is present) */
        "from.participant_id"?: number;
        /** Start the page from the row next to the row with `attempt_id`=`{from.attempt_id}` (all other `{from.*}` parameters are required when `{from.attempt_id}` is present) */
        "from.attempt_id"?: number;
        /** Start the page from the row next to the row with `from_answer_id`=`{from.answer_id}` (all other `{from.*}` parameters are required when `{from.answer_id}` is present) */
        "from.answer_id"?: number;
        /** Start the page from the row next to the row with `activity_type`=`{from.activity_type}` (all other `{from.*}` parameters are required when `{from.activity_type}` is present) */
        "from.activity_type"?:
          | "result_started"
          | "submission"
          | "result_validated"
          | "saved_answer"
          | "current_answer";
        /** Display the first N rows */
        limit?: number;
      };
    };
    responses: {
      /** OK. The array of users answers */
      200: {
        schema: definitions["itemActivityLogResponseRow"][];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Creates an item dependency with parameters from the input data without any effect to access rights.
   * The user should have
   *
   *   * `can_view` >= 'info' on the `{prerequisite_item_id}` item,
   *   * `can_edit` >= 'all' on the `{dependent_item_id}` item,
   *   * if `grant_content_view` = true, the user should also have `can_grant_view` >= 'content'
   *     on the `{dependent_item_id}` item,
   *
   * otherwise the "forbidden" response is returned.
   */
  itemDependencyCreate: {
    parameters: {
      path: {
        dependent_item_id: number;
        prerequisite_item_id: number;
      };
      body: {
        /** The item dependency to create */
        data: definitions["itemDependencyCreateRequest"];
      };
    };
    responses: {
      /** Created. The request has successfully created the item dependency. */
      201: {
        schema: definitions["createdResponse"];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      422: responses["unprocessableEntityResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Deletes the rule without any effect to access rights.
   *
   * * The current-user must have `can_edit` = 'all' on the `{dependent_item_id}`, otherwise the 'forbidden' error is returned.
   */
  itemDependencyDelete: {
    parameters: {
      path: {
        dependent_item_id: number;
        prerequisite_item_id: number;
      };
    };
    responses: {
      200: responses["deletedResponse"];
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Applies the rule, i.e. grants the content access, for all existing participants which meet the condition defined by this dependency. The action doesn't affect access rights of those who doesn't meet the condition anymore.
   *
   * * The item dependency between `{dependent_item_id}` and `{prerequisite_item_id}` must exist with `grant_content_view` = 1, otherwise the 'not found' error is returned.
   * * The current-user must have `can_edit` = 'all' and `can_grant_view` >= 'content' on the `{dependent_item_id}`, otherwise the 'forbidden' error is returned.
   */
  itemDependencyApply: {
    parameters: {
      path: {
        dependent_item_id: number;
        prerequisite_item_id: number;
      };
    };
    responses: {
      200: responses["updatedResponse"];
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      404: responses["notFoundResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Creates a new attempt for the given item with `creator_id` equal to `group_id` of the current user and make it active for the user. If `as_team_id` is given, the created attempt is linked to the `as_team_id` group instead of the user's self group.
   *
   * Restrictions:
   *
   *   * if `as_team_id` is given, it should be a user's parent team group,
   *   * the first item in `{ids}` should be a root activity/skill (groups.root_activity_id/root_skill_id)
   *     of a group the participant is a descendant of,
   *   * `{ids}` should be an ordered list of parent-child items,
   *   * the group creating the attempt should have at least 'content' access on each of the items in `{ids}`,
   *   * the participant should have a started, allowing submission, not ended result for each item but the last,
   *     with `{parent_attempt_id}` (or its parent attempt each time we reach a root of an attempt) as the attempt,
   *   * if `{ids}` consists of only one item, the `{parent_attempt_id}` should be zero,
   *   * the last item in `{ids}` should be either 'Task', 'Course', or 'Chapter',
   *
   * otherwise the 'forbidden' error is returned.
   *
   * If there is already an attempt for the (item, group) pair, `items.allows_multiple_attempts` should be true, otherwise the "unprocessable entity" error is returned.
   */
  attemptCreate: {
    parameters: {
      path: {
        /** slash-separated list of item IDs */
        ids: string;
      };
      query: {
        parent_attempt_id: number;
        as_team_id?: number;
      };
    };
    responses: {
      201: responses["createdWithIDResponse"];
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      422: responses["unprocessableEntityResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Returns brief item information for items listed in `ids` in the user's preferred language (if exist) or the items' default language.
   *
   * Restrictions:
   *   * the list of item IDs should be a valid path from a root item
   *    (`items.id`=`groups.root_activity_id|root_skill_id` for one of the participant's ancestor groups),
   *   * `as_team_id` (if given) should be the current user's team,
   *   * the participant should have at least 'content' access on each listed item except the last one through that path,
   *     and at least 'info' access on the last item,
   *   * all the results within the ancestry of `attempt_id`/`parent_attempt_id` on the items path
   *     (except for the last item if `parent_attempt_id` is given) should be started (`started_at` is not null),
   *
   *   otherwise the 'forbidden' error is returned.
   */
  itemBreadcrumbsGet: {
    parameters: {
      path: {
        /** slash-separated list of IDs */
        ids: string;
      };
      query: {
        /** `id` of an attempt for the second to the last item in the path. This parameter is incompatible with `attempt_id`. */
        parent_attempt_id?: number;
        /** `id` of an attempt for the last item in the path. This parameter is incompatible with `parent_attempt_id`. */
        attempt_id?: number;
        as_team_id?: number;
      };
    };
    responses: {
      /** OK. Breadcrumbs data */
      200: {
        schema: {
          /** the attempt for this item (result) within ancestry of `attempt_id` or `parent_attempt_id` (skipped for the last item if `parent_attempt_id` is used) */
          attempt_id?: string;
          /** the order of this attempt result among the other results (within the parent attempt) sorted by `started_at` (only for items allowing multiple submissions; skipped for the last item if `parent_attempt_id` is used) */
          attempt_number?: string;
          item_id: string;
          language_tag: string;
          title: string;
          type: "Chapter" | "Task" | "Course" | "Skill";
        }[];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Allows to enter an item requiring explicit entry as a user or as a team (if `as_team_id` is given).
   *
   * Restrictions:
   *   * the last item in `{ids}` should require explicit entry;
   *   * `as_team_id` (if given) should be the current user's team;
   *   * the first item in `{ids}` should be a root activity/skill (groups.root_activity_id/root_skill_id)
   *     of a group the participant is a descendant of;
   *   * `{ids}` should be an ordered list of parent-child items;
   *   * the group (the user or his team) should have at least 'content' access
   *     on each of the items in `{ids}` except the last one and at least 'info' access for the last one;
   *   * the group should have a started, allowing submission, not ended result for each item but the last,
   *     with `{parent_attempt_id}` (or its parent attempt each time we reach a root of an attempt) as the attempt;
   *   * if `{ids}` consists of only one item, the `{parent_attempt_id}` should be zero;
   *   * the group (the user or his team) must be qualified for the last item in `{ids}` (itemGetEntryState returns "ready").
   *
   * Otherwise, the "Forbidden" response is returned.
   */
  itemEnter: {
    parameters: {
      path: {
        /** slash-separated list of item IDs */
        ids: string;
      };
      query: {
        /** `id` of an attempt which will be used as a parent attempt for the participation */
        parent_attempt_id: number;
        as_team_id?: number;
      };
    };
    responses: {
      201: responses["itemEnterResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Creates a new started result for the given item and attempt or sets `started_at` of an existing result (if it hasn't been set). If `as_team_id` is given, the created result is linked to the `as_team_id` group instead of the user's self group.
   *
   * Restrictions:
   *
   *   * if `as_team_id` is given, it should be a user's parent team group,
   *   * the first item in `{ids}` should be a root activity/skill (groups.root_activity_id/root_skill_id) of a group
   *     the participant is a descendant of,
   *   * the last item in `{ids}` should not require explicit entry (`items.requires_explicit_entry` should be false),
   *   * `{ids}` should be an ordered list of parent-child items,
   *   * the group starting the result should have at least 'content' access on each of the items in `{ids}`,
   *   * the participant should have a started, allowing submission, not ended result for each item but the last,
   *     with `{attempt_id}` (or its parent attempt each time we reach a root of an attempt) as the attempt,
   *   * if `{ids}` consists of only one item, the `{attempt_id}` should be zero,
   *
   * otherwise the 'forbidden' error is returned.
   */
  resultStart: {
    parameters: {
      path: {
        /** slash-separated list of item IDs */
        ids: string;
      };
      query: {
        attempt_id: number;
        as_team_id?: number;
      };
    };
    responses: {
      201: responses["updatedResponse"];
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Creates new started results (or starts not started existing ones) for an item path if needed and returns the last attempt in the chain.
   * Of all possible chains of attempts the service chooses the one having missing/not-started results located closer to the end of the path, preferring chains having less missing/not-started results and having higher values of `attempt_id`. If there is no result for the first item, the service tries to create an attempt chain starting with the zero attempt. The chain of attempts cannot have missing results for items requiring explicit entry or require to start/create results within or below ended/not-allowing-submissions attempts.
   * If `as_team_id` is given, the created/updated results are linked to the `as_team_id` group instead of the user's self group.
   *
   * Restrictions:
   *
   *   * if `as_team_id` is given, it should be a user's parent team group,
   *   * the first item in `{ids}` should be a root activity/skill (groups.root_activity_id/root_skill_id) of a group
   *     the participant is a descendant of,
   *   * `{ids}` should be an ordered list of parent-child items,
   *   * the group starting results should have at least 'content' access on each of the items in `{ids}`,
   *
   * otherwise the 'forbidden' error is returned.
   */
  resultStartPath: {
    parameters: {
      path: {
        /** slash-separated list of item IDs */
        ids: string;
      };
      query: {
        as_team_id?: number;
      };
    };
    responses: {
      /** Created. Success response with the attempt id for the last item in the path */
      201: {
        schema: {
          data: {
            /** The attempt linked to the last item in the path */
            attempt_id: number;
          };
          /** updated */
          message: "updated";
          /** true */
          success: true;
        };
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Returns data related to the specified item, and the current user's (or the team's given in `{as_team_id}`) permissions on it (from tables `items`, `items_string`, `permissions_generated`).
   *
   * * If the specified item is not visible by the current user (or the team given in `as_team_id`), the 'not found' response is returned.
   * * If `{language_tag}` is given, but there is no items_strings row for the `{item_id}` and `{language_tag}`, the 'not found' response is returned as well.
   * * If `as_team_id` is given, it should be a user's parent team group, otherwise the "forbidden" error is returned.
   * * If `{watched_group_id}` is given, the user should ba a manager of the group with the 'can_watch_members' permission, otherwise the "forbidden" error is returned. Permissions of the watched group are only shown if the current user can watch the item or grant permissions to both the watched group and the item.
   */
  itemView: {
    parameters: {
      path: {
        item_id: number;
      };
      query: {
        as_team_id?: number;
        watched_group_id?: number;
        language_tag?: string;
      };
    };
    responses: {
      /** OK. Success response with item data */
      200: {
        schema: definitions["itemResponse"];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      404: responses["notFoundResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Changes the given item's properties using the input data.
   *
   * If the `children` array is given, the service removes relations between the item and its former children, inserts relations between the item and its new children into `items_items`, and propagates `permissions_generated`. (The only allowed parent-child relations are skills-*, chapter-task, chapter-course, chapter-chapter. Otherwise the "bad request" error is returned.)
   *
   * If `requires_explicit_entry` is being set to true and `participants_group_id` is NULL, the service creates a participants group, links `participants_group_id` to it, and gives this group 'can_view:content' permission on the new item.
   *
   * The user should have
   *
   *   * `can_view` >= 'content' on the item, otherwise the "forbidden" response is returned;
   *   * `can_edit` >= 'children' on the item to edit children or `can_edit` >= 'all' to edit the item's properties,
   *     otherwise the "forbidden" response is returned;
   *   * `can_view` != 'none' on the `children` items (if any), otherwise the "bad request"
   *     response is returned.
   */
  itemUpdate: {
    parameters: {
      path: {
        item_id: number;
      };
      body: {
        /** New item property values */
        data: definitions["itemEditRequest"];
      };
    };
    responses: {
      200: responses["updatedResponse"];
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Removes an item and objects linked to it.
   *
   * The service deletes `answers`, `groups_contest_items`, `item_dependencies` (by `item_id` and `dependent_item_id`), `items_ancestors` (by `child_item_id`), `items_items` (by `child_item_id`), `items_strings`, `permissions_generated`, `permissions_granted`, `permissions_propagate`, `results` linked to the item.
   *
   * The authenticated user should be an owner of the `{item_id}`, otherwise the "forbidden" error is returned.
   * Also, the item must not have any children, otherwise the "unprocessable entity" error is returned.
   */
  itemDelete: {
    parameters: {
      path: {
        item_id: number;
      };
    };
    responses: {
      200: responses["deletedResponse"];
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      422: responses["unprocessableEntityResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Return answers (i.e., saved answers, current answer and submissions) for a given item and user, or from a given attempt.
   * * One of `author_id` or `attempt_id` is required.
   * * The user should have at least 'content' access to the item.
   * * If `author_id` is given, the authenticated user should be the input `author_id` or a manager of a group containing the input `author_id`.
   * * If `attempt_id` is given, the authenticated user should be a member or a manager of the group attached to the attempt.
   *
   * Users' `first_name` and `last_name` are only shown for the authenticated user or if the user approved access to their personal info for some group managed by the authenticated user.
   */
  answersList: {
    parameters: {
      path: {
        item_id: number;
      };
      query: {
        author_id?: number;
        attempt_id?: number;
        sort?: ("created_at" | "-created_at" | "id" | "-id")[];
        /** Start the page from the answer next to the answer with `answers.id`=`{from.id}` */
        "from.id"?: number;
        /** Display the first N answers */
        limit?: number;
      };
    };
    responses: {
      /** OK. Success response with an array of answers */
      200: {
        schema: definitions["answersResponseAnswer"][];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Returns attempts of the current participant (the current user or `{as_team_id}` team) with their results for the given item within the parent attempt.
   *
   * `first_name` and `last_name` of attempt creators are only visible to attempt creators themselves and to managers of those attempt creators' groups to which they provided view access to personal data.
   *
   * Restrictions:
   *   * `{as_team_id}` (if given) should be the current user's team,
   *   * the participant should have at least 'content' access on the item,
   *   * if `{attempt_id}` is given, it should exist for the participant in order to determine `{parent_attempt_id}`
   *     (we assume that the 'zero attempt' always exists and it is its own parent attempt),
   *
   * otherwise the 'forbidden' error is returned.
   */
  attemptsList: {
    parameters: {
      path: {
        item_id: number;
      };
      query: {
        /** `id` of a parent attempt. This parameter is incompatible with `attempt_id`. */
        parent_attempt_id?: number;
        /** `id` of an attempt for the `{item_id}`. This parameter is incompatible with `parent_attempt_id`. */
        attempt_id?: number;
        as_team_id?: number;
        sort?: ("id" | "-id")[];
        /** Start the page from the attempt next to the attempt with `results.attempt_id` = `{from.id}` */
        "from.id"?: number;
        /** Display first N attempts */
        limit?: number;
      };
    };
    responses: {
      /** OK. Success response with an array of attempts */
      200: {
        schema: definitions["attemptsListResponseRow"][];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Modifies values of an attempt result's properties a participant is able to modify.
   *
   * Restrictions:
   *
   *   * `{as_team_id}` (if given) should be the current user's team,
   *   * the participant should have a `results` row for the `{item_id}`-`{attempt_id}` pair,
   *
   * otherwise the 'forbidden' error is returned.
   */
  resultUpdate: {
    parameters: {
      path: {
        item_id: number;
        attempt_id: number;
      };
      query: {
        as_team_id?: number;
      };
      body: {
        /** Result properties to modify */
        data: definitions["resultUpdateRequest"];
      };
    };
    responses: {
      200: responses["updatedResponse"];
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Creates a "saved" answer from a current snapshot.
   * * The authenticated user should have at least 'content' access to the `{item_id}`.
   * * `{as_team_id}` (if given) should be the user's team.
   * * There should be a row in the `results` table with `attempt_id` = `{attempt_id}`, `participant_id` = the user's group (or `{as_team_id}` if given), `item_id` = `{item_id}`.
   * If any of the preconditions fails, the 'forbidden' error is returned.
   */
  answerCreate: {
    parameters: {
      path: {
        attempt_id: number;
        item_id: number;
      };
      query: {
        as_team_id?: number;
      };
      body: {
        "answer information": definitions["answerData"];
      };
    };
    responses: {
      /** Created. The request has successfully saved the answer. */
      201: {
        schema: definitions["createdResponse"];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Update participant's current answer. Used for auto-saving while working on a task.
   * * The authenticated user should have at least 'content' access to the `{item_id}`.
   * * `{as_team_id}` (if given) should be the user's team.
   * * There should be a row in the `results` table with `attempt_id` = `{attempt_id}`, `participant_id` = the user's group (or `{as_team_id}` if given), `item_id` = `{item_id}`
   * If any of the preconditions fails, the 'forbidden' error is returned.
   */
  currentAnswerUpdate: {
    parameters: {
      path: {
        attempt_id: number;
        item_id: number;
      };
      query: {
        as_team_id?: number;
      };
      body: {
        "current answer information": definitions["answerData"];
      };
    };
    responses: {
      201: responses["updatedResponse"];
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Generate a task token with the refreshed attempt.
   *
   * * `latest_activity_at` of `results` is set to the current time.
   * * Then the service returns a task token with fresh data for the attempt for the given item.
   *
   * Restrictions:
   *
   *   * if `{as_team_id}` is given, it should be a team and the current user should be a member of this team,
   *   * the user (or `{as_team_id}`) should have at least 'content' access to the item,
   *   * the item should be either 'Task' or 'Course',
   *   * there should be a row in the `results` table with `participant_id` equal to the user's group (or `{as_team_id}`),
   *     `attempt_id` = `{attempt_id}`, `item_id` = `{item_id}`, `started_at` set,
   *   * the attempt with (`participant_id`, `{attempt_id}`) should have allows_submissions_until in the future,
   *
   * otherwise the 'forbidden' error is returned.
   */
  itemTaskTokenGenerate: {
    parameters: {
      path: {
        attempt_id: number;
        item_id: number;
      };
      query: {
        as_team_id?: number;
      };
    };
    responses: {
      /** OK. Success response with the fresh task token */
      200: {
        schema: {
          data: {
            task_token: string;
          };
          /** updated */
          message: "updated";
          /** true */
          success: true;
        };
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Publishes score obtained for the item within the attempt to LTI (via the login module).
   *
   * Restrictions:
   *
   *   * if `as_team_id` is given, it should be a user's parent team group,
   *   * the current user should have at least 'content' access on each of the `{item_id}` item,
   *   * the current user should have non-empty `login_id`,
   *
   * otherwise the 'forbidden' error is returned.
   */
  resultPublish: {
    parameters: {
      path: {
        item_id: number;
        attempt_id: number;
      };
      query: {
        /** fails with 'bad request' error if given, this service does not currently support team work */
        as_team_id?: number;
      };
    };
    responses: {
      200: responses["publishedOrFailedResponse"];
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Lists all paths from a root (`root_activity_id`|`root_skill_id` of groups the participant is descendant of) to the given item that the participant may have used to access this item, so path for which the participant has a started attempt (possibly ended/not-allowing-submissions) on every item.
   *
   * The participant is `participant_id` (if given) or the current user (otherwise).
   *
   * Paths can contain only items visible to the current user (`can_view`>='content' on every item on the path but the last one and `can_view`>='info' for the last one). The item info (`title` and `language_tag`) in the paths is in the current user's language, or the item's default language (if not available).
   *
   * Restrictions:
   *
   *   * if `participant_id` is given, it should be a descendant of a group the current user can manage with `can_watch_members`,
   *   * at least one path should exist,
   *
   * otherwise the 'forbidden' error is returned.
   */
  itemBreadcrumbsFromRootsGet: {
    parameters: {
      path: {
        item_id: number;
      };
      query: {
        participant_id?: number;
      };
    };
    responses: {
      /** OK. Success response with the found item path */
      200: {
        schema: definitions["breadcrumbElement"][][];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Lists children of the specified item and the current user's (or the team's given in `as_team_id`) interactions with them (from tables `items`, `items_items`, `items_string`, `results`, `permissions_generated`) within the context of the given `{attempt_id}`. Only items visible to the current user (or to the `{as_team_id}` team) are shown. If `{show_invisible_items}` = 1, items invisible to the current user (or to the `{as_team_id}` team) are shown too, but with a limited set of fields. If `{watched_group_id}` is given, some additional info about the given group's results on the items is shown.
   *
   * * The current user (or the team given in `as_team_id`) should have at least 'content' permissions on the specified item and a started result for it, otherwise the 'forbidden' response is returned.
   * * If `as_team_id` is given, it should be a user's parent team group, otherwise the "forbidden" error is returned.
   * * If `{watched_group_id}` is given, the user should ba a manager of the group with the 'can_watch_members' permission, otherwise the "forbidden" error is returned.
   */
  itemChildrenView: {
    parameters: {
      path: {
        item_id: number;
      };
      query: {
        /** `id` of an attempt for the item. */
        attempt_id: number;
        /** If 1, show invisible items as well */
        show_invisible_items?: 0 | 1;
        as_team_id?: number;
        watched_group_id?: number;
      };
    };
    responses: {
      /** OK. Success response with item children data */
      200: {
        schema: definitions["childItem"][];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Returns the latest auto-saved ('Current') answer for the given `{item_id}` and `{attempt_id}`.
   * * The user should have at least 'content' access rights to the `item_id` item.
   * * The user should be able to see answers related to his group's attempts so the user should be a member of the `answers.participant_id` team or `answers.participant_id` should be equal to the user's self group.
   * * `{as_team_id}` (if given) should be the user's team.
   *
   * If any of the preconditions fails, the 'forbidden' error is returned.
   */
  currentAnswerGet: {
    parameters: {
      path: {
        item_id: number;
      };
      query: {
        attempt_id: number;
        as_team_id?: number;
      };
    };
    responses: {
      200: responses["itemAnswerGetResponse"];
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Lists dependent items for the specified item and the current user's (or the team's given in `as_team_id`) interactions with them (from tables `items`, `item_dependencies`, `items_string`, `results`, `permissions_generated`). Only items visible to the current user (or to the `{as_team_id}` team) are shown. If `{watched_group_id}` is given, some additional info about the given group's results on the items is shown.
   *
   * * The current user (or the team given in `as_team_id`) should have at least 'info' permissions on the specified item, otherwise the 'forbidden' response is returned.
   * * If `as_team_id` is given, it should be a user's parent team group, otherwise the "forbidden" error is returned.
   * * If `{watched_group_id}` is given, the user should ba a manager of the group with the 'can_watch_members' permission, otherwise the "forbidden" error is returned.
   */
  itemDependenciesView: {
    parameters: {
      path: {
        item_id: number;
      };
      query: {
        as_team_id?: number;
        watched_group_id?: number;
      };
    };
    responses: {
      /** OK. Success response with dependent items */
      200: {
        schema: definitions["prerequisiteOrDependencyItem"][];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * For the given item requiring explicit entry and the given participant (the current user or his team if `as_team_id` is set), returns the entry state, i.e. whether the participant can enter the item, and info on each team member.
   *
   * `first_name` and `last_name` of other members are only visible to managers of those members' groups to which they provided view access to personal data.
   *
   * The entry state is one of:
   *   * 'already_started' if the participant has an `attempts` row for the item
   *     (with `attempts.root_item_id` = `{item_id}`) allowing submissions;
   *
   *   * 'not_ready' if the team itself cannot enter the item
   *     while there are more members than `entry_max_team_size` or
   *     the team/user doesn't satisfy the item's entry condition which is computed
   *     in accordance with `items.entry_min_admitted_members_ratio` as follows:
   *
   *       * "None": no additional conditions (the team/user can enter the item);
   *
   *       * "One": the current time needs to be between
   *         `permissions_granted.can_enter_from` and `permissions_granted.can_enter_until`
   *         and between `items.entering_time_min` and `items.entering_time_max`
   *         for the item and one of the group ancestors of either the user (if participating alone)
   *         or at least one member of the team;
   *
   *       * "All": same but all members of the team;
   *
   *       * "Half": same but half of the members (ceil-rounded) of the team;
   *
   *   * 'not_ready' if the participant has an `attempts` row for the item (with `attempts.root_item_id` = `{item_id}`)
   *     while the item's `allows_multiple_attempts` is false;
   *
   *   * 'not_ready' if at least one of the team's members as a member of another team
   *     has an `attempts` row for the item (with `attempts.root_item_id` = `{item_id}`)
   *     while the item's `allows_multiple_attempts` is false or an active (not expired) attempt;
   *
   *   * 'not_ready' if the item's `items.entry_frozen_teams` = 1,
   *     but the team membership is not frozen (`groups.frozen_membership` = 0);
   *
   *   * 'ready' otherwise.
   *
   * Restrictions:
   *   * `item_id` should require explicit entry;
   *   * `as_team_id` (if given) should be one of the current user's teams;
   *   * `as_team_id` should be given if the item is team-only and should not be given if the item is user-only;
   *   * the authenticated user (or his team) should have at least 'info' access to the item.
   *
   * Otherwise, the "Forbidden" response is returned.
   */
  itemGetEntryState: {
    parameters: {
      path: {
        /** `id` of an item to enter */
        item_id: number;
      };
      query: {
        as_team_id?: number;
      };
    };
    responses: {
      /** OK. Success response with the entry state info */
      200: {
        schema: definitions["itemGetEntryStateResponse"];
      };
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Returns data needed to display the navigation menu (for `item_id` and its children) within the context of the given `{attempt_id}`/`{child_attempt_id}` (one of those should be given). Only items visible to the current user (or to the `{as_team_id}` team) are shown. If `{watched_group_id}` is given, some additional info about the given group's results on the items is shown.
   *
   * If `{child_attempt_id}` is given, the context-defining attempt id of the input item is either the same `{child_attempt_id}` or the `parent_attempt_id` of the given `{child_attempt_id}` (depending on the `root_item_id` of the `{child_attempt_id}`).
   *
   * * If the specified `{item_id}` doesn't exist or is not visible to the current user (or to the `{as_team_id}` team),
   *   of if there is no started result of the user/`{as_team_id}` for the context attempt id and the item,
   *   the 'forbidden' response is returned.
   *
   *
   * * If `{as_team_id}` is given, it should be a user's parent team group,
   *   otherwise the "forbidden" error is returned.
   *
   *
   * * If `{watched_group_id}` is given, the user should ba a manager of the group with the 'can_watch_members' permission,
   *   otherwise the "forbidden" error is returned.
   */
  itemNavigationView: {
    parameters: {
      path: {
        item_id: number;
      };
      query: {
        /** `id` of an attempt for the item. This parameter is incompatible with `{child_attempt_id}`. */
        attempt_id?: number;
        /** `id` of an attempt for one of the item's children. This parameter is incompatible with `{attempt_id}`. */
        child_attempt_id?: number;
        as_team_id?: number;
        watched_group_id?: number;
      };
    };
    responses: {
      /** OK. Navigation data */
      200: {
        schema: definitions["itemNavigationResponse"];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Lists the groups having `type`='Session', `is_official_session`=true, `is_public`=true, `root_activity_id`=`{item_id}` along with their parent groups (public or managed by the current user or having the current user as a member).
   *
   * Restrictions:
   *   * the current user should have at least 'info' permission on the item,
   *
   * otherwise the 'forbidden' error is returned.
   */
  officialSessionsList: {
    parameters: {
      path: {
        item_id: number;
      };
      query: {
        sort?: (
          | "group_id"
          | "-group_id"
          | "expected_start"
          | "-expected_start"
          | "expected_start$"
          | "-expected_start$"
          | "name"
          | "-name"
        )[];
        /** Start the page from the official session next to the official session with `groups.id` = `{from.group_id}` */
        "from.group_id"?: number;
        /** Display first N official sessions */
        limit?: number;
      };
    };
    responses: {
      /** OK. Success response with an array of official sessions */
      200: {
        schema: definitions["officialSessionsListResponseRow"][];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Lists parents of the specified item and the current user's (or the team's given in `as_team_id`) interactions with them (from tables `items`, `items_items`, `items_string`, `results`, `permissions_generated`) within the context of the given `{attempt_id}`. Only items visible to the current user (or to the `{as_team_id}` team) are shown. If `{watched_group_id}` is given, some additional info about the given group's results on the items is shown.
   *
   * * The current user (or the team given in `as_team_id`) should have at least 'info' permissions on the specified item, otherwise the 'forbidden' response is returned.
   * * If `as_team_id` is given, it should be a user's parent team group, otherwise the "forbidden" error is returned.
   * * If `{watched_group_id}` is given, the user should ba a manager of the group with the 'can_watch_members' permission, otherwise the "forbidden" error is returned.
   */
  itemParentsView: {
    parameters: {
      path: {
        item_id: number;
      };
      query: {
        /** `id` of an attempt for the item. */
        attempt_id: number;
        as_team_id?: number;
        watched_group_id?: number;
      };
    };
    responses: {
      /** OK. Success response with item parents data */
      200: {
        schema: definitions["parentItem"][];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Returns the current progress of a participant on a given item.
   *
   * For `{item_id}` and all its visible children, displays the results of the given participant (current user or `as_team_id` (if given) or `watched_group_id` (if given)). Only one of `as_team_id` and `watched_group_id` can be given. The results are sorted by `items_items.child_order`.
   *
   * If the participant is a user, only the result corresponding to his best score counts (across all his teams and his own results) disregarding whether or not the score was done in a team.
   *
   * Restrictions:
   * * The current user (or the team given in `as_team_id`) should have at least 'content' permissions on `{item_id}`,
   *   otherwise the 'forbidden' response is returned.
   *
   * * If `{as_team_id}` is given, it should be a user's parent team group,
   *   otherwise the "forbidden" error is returned.
   *
   * * If `{watched_group_id}` is given, the user should be a manager of the group with the 'can_watch_members' permission,
   *   otherwise the "forbidden" error is returned.
   *
   * * If `{watched_group_id}` is given, it should be a user group or a team,
   *   otherwise the "forbidden" error is returned.
   *
   * * If `{watched_group_id}` is given, the current user should have `can_watch` >= 'result' on the `{item_id}` item,
   *   otherwise the "forbidden" error is returned.
   */
  groupParticipantProgress: {
    parameters: {
      path: {
        item_id: number;
      };
      query: {
        as_team_id?: number;
        watched_group_id?: number;
      };
    };
    responses: {
      /** OK. Success response with the participant's progress on item's children */
      200: {
        schema: definitions["groupParticipantProgressResponse"];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Finds a path from any of root items to a given item.
   *
   * The path consists only of the items visible to the participant (`can_view`>='content' for all the items except for the last one and `can_view`>='info' for the last one). Of all possible paths the service chooses the one having missing/not-started results located closer to the end of the path, preferring paths having less missing/not-started results and having higher values of `attempt_id`. The chain of attempts of the path cannot have missing results for items requiring explicit entry or not started results within or below ended/not-allowing-submissions attempts.
   *
   * If `as_team_id` is given, the attempts/results of the path are linked to the `as_team_id` group instead of the user's self group.
   *
   * Restrictions:
   *
   *   * if `as_team_id` is given, it should be a user's parent team group,
   *   * at least one path should exist,
   *
   * otherwise the 'forbidden' error is returned.
   */
  itemPathFromRootFind: {
    parameters: {
      path: {
        item_id: number;
      };
      query: {
        as_team_id?: number;
      };
    };
    responses: {
      /** OK. Success response with the found item path */
      200: {
        schema: {
          path: string[];
        };
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Lists prerequisite items for the specified item and the current user's (or the team's given in `as_team_id`) interactions with them (from tables `items`, `item_dependencies`, `items_string`, `results`, `permissions_generated`). Only items visible to the current user (or to the `{as_team_id}` team) are shown. If `{watched_group_id}` is given, some additional info about the given group's results on the items is shown.
   *
   * * The current user (or the team given in `as_team_id`) should have at least 'info' permissions on the specified item, otherwise the 'forbidden' response is returned.
   * * If `as_team_id` is given, it should be a user's parent team group, otherwise the "forbidden" error is returned.
   * * If `{watched_group_id}` is given, the user should ba a manager of the group with the 'can_watch_members' permission, otherwise the "forbidden" error is returned.
   */
  itemPrerequisitesView: {
    parameters: {
      path: {
        item_id: number;
      };
      query: {
        as_team_id?: number;
        watched_group_id?: number;
      };
    };
    responses: {
      /** OK. Success response with prerequisite items */
      200: {
        schema: definitions["prerequisiteOrDependencyItem"][];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Updates the corresponding `items_strings` row identified by `item_id` and `language_tag` if exists or creates a new one otherwise.
   *
   * If `language_tag` = 'default', uses the item’s default language.
   *
   * The user should have `can_view` >= 'content' and `can_edit` >= 'all' on the item, otherwise the "forbidden" response is returned.
   */
  itemStringUpdate: {
    parameters: {
      path: {
        item_id: number;
        language_tag: string;
      };
      body: {
        /** New item property values */
        data: definitions["itemStringUpdateRequest"];
      };
    };
    responses: {
      200: responses["updatedResponse"];
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Saves the hint request into `results` and generates a new task token.
   *
   * Restrictions:
   *
   *   * `task_token` should belong to the current user, otherwise the "bad request" response is returned.
   *   * The current user should have submission rights to the `task_token`'s item,
   *     otherwise the "forbidden" response is returned.
   *   * There should be a row in the `results` with `participant_id`, `attempt_id`, and `item_id` matching the tokens
   *     and `attempts.allows_submissions_until` should be equal to time in the future,
   *     otherwise the "not found" response is returned.
   */
  itemGetHintToken: {
    parameters: {
      body: {
        data: {
          /** A hint request token generated by a task platform */
          hint_requested?: string;
          /** A task token previously generated by AlgoreaBackend */
          task_token: string;
        };
      };
    };
    responses: {
      /** Created. Success response with the newly created task token */
      201: {
        schema: {
          data: {
            task_token: string;
          };
          /** created */
          message: "created";
          /** true */
          success: true;
        };
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      404: responses["notFoundResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Returns rows from `answers` and started/validated `results` with additional info on users and items for the participant or the `{watched_group_id}` group (only one of `{as_team_id}` and `{watched_group_id}` can be given).
   *
   * If possible, items titles are shown in the authenticated user's default language. Otherwise, the item's default language is used.
   *
   * `first_name` and `last_name` of users are only visible to the users themselves and to managers of those users' groups to which they provided view access to personal data.
   *
   * If `{watched_group_id}` is given, all rows of the result are related to descendant groups of `{watched_group_id}` and items that are visible to the current user (at least 'info' access with `can_watch` >= 'result').
   *
   * If `{watched_group_id}` is not given, all rows of the result are related to the participant group (the current user or `{as_team_id}`) and items that are visible to the current user (at least 'info' access).
   */
  itemActivityLogForAllItems: {
    parameters: {
      query: {
        as_team_id?: number;
        /** The current user should be a manager of the watched group with `can_watch_members` = true, otherwise the 'forbidden' error is returned */
        watched_group_id?: number;
        /** Start the page from the row next to the row with `item_id`=`{from.item_id}` (all other `{from.*}` parameters are required when `{from.item_id}` is present) */
        "from.item_id"?: number;
        /** Start the page from the row next to the row with `participant_id`=`{from.participant_id}` (all other `{from.*}` parameters are required when `{from.participant_id}` is present) */
        "from.participant_id"?: number;
        /** Start the page from the row next to the row with `attempt_id`=`{from.attempt_id}` (all other `{from.*}` parameters are required when `{from.attempt_id}` is present) */
        "from.attempt_id"?: number;
        /** Start the page from the row next to the row with `from_answer_id`=`{from.answer_id}` (all other `{from.*}` parameters are required when `{from.answer_id}` is present) */
        "from.answer_id"?: number;
        /** Start the page from the row next to the row with `activity_type`=`{from.activity_type}` (all other `{from.*}` parameters are required when `{from.activity_type}` is present) */
        "from.activity_type"?:
          | "result_started"
          | "submission"
          | "result_validated"
          | "saved_answer"
          | "current_answer";
        /** Display the first N rows */
        limit?: number;
      };
    };
    responses: {
      /** OK. The array of users answers */
      200: {
        schema: definitions["itemActivityLogResponseRow"][];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Saves the grade returned by a grading app into the `gradings` table and updates the attempt results in the DB. When the `score` is big enough, the service unlocks locked dependent items (if any) and updates `bAccessSolutions` of the task token.
   *
   * Restrictions:
   *
   *   * `task_token`, `score_token`/`answer_token` should belong to the current user, otherwise the "bad request"
   *      response is returned;
   *   * `idItemLocal`, `itemUrl`, `idAttempt` of the `task_token` should match ones in the `score_token`/`answer_token`,
   *     otherwise the "bad request" response is returned;
   *   * the answer should exist and should have not been graded, otherwise the "forbidden" response is returned.
   */
  saveGrade: {
    parameters: {
      body: {
        data: {
          /** An answer token generated by AlgoreaBackend (required for platforms not supporting tokens) */
          answer_token?: string;
          /** A score returned by the grader (required for platforms not supporting tokens) */
          score?: number;
          /** A score token generated by the grader (required for platforms supporting tokens) */
          score_token?: string;
          /** A task token previously generated by AlgoreaBackend */
          task_token: string;
        };
      };
    };
    responses: {
      /** Created. Success response with the newly created task token */
      201: {
        schema: {
          data: {
            /** The updated task token */
            task_token: string;
            /** Whether the full score was obtained on this grading */
            validated: boolean;
          };
          /** created */
          message: "created";
          /** true */
          success: true;
        };
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /** Searches for visible (`can_view` >= 'info') items, basing on a substring of their titles in the current user's (if exists, otherwise default) language. */
  itemSearch: {
    parameters: {
      query: {
        search: string;
        types_include?: ("Chapter" | "Task" | "Course" | "Skill")[];
        types_exclude?: ("Chapter" | "Task" | "Course" | "Skill")[];
        /** Display the first N items */
        limit?: number;
      };
    };
    responses: {
      /** OK. Success response with an array of items */
      200: {
        schema: definitions["itemSearchResponseRow"][];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Creates a batch of users:
   * * creates a new row in users_batches,
   * * creates new users in the login module,
   * * inserts the created users into the `users` table,
   * * adds the created users into groups specified as `subgroups[...].group_id` giving all the required approvals.
   *
   * Restrictions:
   * * The authenticated user (or one of his group ancestors) should be a manager of the group
   *   (directly, or of one of its ancestors) linked to the `group_prefix`
   *   with at least 'can_manage:memberships', otherwise the 'forbidden' response is returned.
   * * The 'subgroup.group_id'-s should be descendants of the group linked to the `group_prefix` or be the group itself,
   *   otherwise the 'forbidden' response is returned.
   * * The 'subgroup.group_id'-s should not be of type 'User', otherwise the 'forbidden' response is returned. * The `group_prefix.allow_new` should be true, otherwise the 'forbidden' response is returned. * 32^`postfix_length` should be greater than 2 * sum of `subgroups.count`
   *   (to prevent being unable to generate unique logins), otherwise the 'bad request' response is returned.
   * * Sum of `subgroups.count` + sum of sizes of existing batches under the same `group_prefix`
   *   should not be greater than `max_users` of the prefix, otherwise the 'bad request' response is returned.
   */
  createUserBatch: {
    parameters: {
      body: {
        /** The user batch to create */
        data: definitions["createUserBatchRequest"];
      };
    };
    responses: {
      /** Created. Success response with the newly created task token */
      201: {
        schema: {
          data: definitions["createUserBatchResultRow"][];
          /** created */
          message: "created";
          /** true */
          success: true;
        };
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /**
   * Lets a group manager remove user batches and all users having "{group_prefix}_{custom_prefix}_" as login prefix.
   *
   *
   * If the preconditions are satisfied, the service
   *
   *   * requests the login module to delete the users with "{group_prefix}\_{custom_prefix}\_" as prefix
   *     (/platform_api/accounts_manager/delete with the `prefix` parameter);
   *
   *   * deletes all users with "{group_prefix}\_{custom_prefix}\_" as prefix
   *     (ignoring the membership locks on groups that the authenticated user manages (but not others!));
   *
   *   * deletes the user batch entry.
   *
   * As we do not lock the DB between the preconditions checking and the actual deletion
   * with the call to the login module in the middle, there is possibility of deleting users
   * that haven't been checked or haven't been removed from the login module.
   *
   * If the local user deletion fails because of DB failure, there might be inconsistency between the DB
   * and the login module which can be fixed by retrying the request with the same parameters.
   *
   * Preconditions:
   *
   * * The authenticated user should be a manager of the `group_prefix`'s group (or its ancestor)
   *   with `can_manage` >= 'memberships', otherwise the 'forbidden' error is returned.
   *
   * * If there are users with locked membership in groups the current user cannot manage,
   *   the 'unprocessable entity' error is returned.
   */
  userBatchRemove: {
    parameters: {
      path: {
        group_prefix: string;
        custom_prefix: string;
      };
    };
    responses: {
      200: responses["deletedResponse"];
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      422: responses["unprocessableEntityResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /** Lists the batches of users whose prefix can be used in the given group (i.e., the `group_id` is a descendant of the prefix group). Only those user batches are shown for which the authenticated user (or one of his group ancestors) is a manager of the prefix group (or its ancestor) with at least 'can_manage:memberships'. */
  userBatchesView: {
    parameters: {
      path: {
        group_id: number;
      };
      query: {
        sort?: (
          | "group_prefix"
          | "-group_prefix"
          | "custom_prefix"
          | "-custom_prefix"
          | "size"
          | "-size"
        )[];
        /** Start the page from the batch next to the batch with `user_batches.group_prefix` = `{from.group_prefix}` (`{from.custom_prefix}` is required when `{from.group_prefix}` is given) */
        "from.group_prefix"?: string;
        /** Start the page from the batch next to the batch with `user_batches.custom_prefix` = `{from.custom_prefix}` (`{from.group_prefix}` is required when `{from.custom_prefix}` is given) */
        "from.custom_prefix"?: string;
        /** Display the first N user batches */
        limit?: number;
      };
    };
    responses: {
      /** OK. The array of user batches */
      200: {
        schema: definitions["userBatch"][];
      };
      400: responses["badRequestResponse"];
      401: responses["unauthorizedResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /** Returns data from the `users` table for the given `{user_id}` (`first_name` and `last_name` are only shown for the authenticated user or if the user approved access to their personal info for some group managed by the authenticated user) along with some permissions if the current user is a manager. */
  userViewByID: {
    parameters: {
      path: {
        user_id: number;
      };
    };
    responses: {
      /** OK. Success response with user's data */
      200: {
        schema: definitions["userViewResponse"];
      };
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      404: responses["notFoundResponse"];
      500: responses["internalErrorResponse"];
    };
  };
  /** Returns data from the `users` table for the given `{login}` (`first_name` and `last_name` are only shown for the authenticated user or if the user approved access to their personal info for some group managed by the authenticated user) along with some permissions if the current user is a manager. */
  userViewByLogin: {
    parameters: {
      path: {
        login: string;
      };
    };
    responses: {
      /** OK. Success response with user's data */
      200: {
        schema: definitions["userViewResponse"];
      };
      401: responses["unauthorizedResponse"];
      403: responses["forbiddenResponse"];
      404: responses["notFoundResponse"];
      500: responses["internalErrorResponse"];
    };
  };
}
